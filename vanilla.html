<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Nesa Explorer 5 Edition</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'MS Sans Serif', 'Microsoft Sans Serif', sans-serif;
            background: #008080;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #win98-frame {
            width: 90vw;
            height: 90vh;
            background: #C0C0C0;
            border: 3px solid;
            border-color: #FFFFFF #000000 #000000 #FFFFFF;
            box-shadow: inset 1px 1px 0 #DFDFDF, inset -1px -1px 0 #808080;
            display: flex;
            flex-direction: column;
        }
        #win98-titlebar {
            background: linear-gradient(to right, #000080, #1084D0);
            color: white;
            padding: 3px 5px;
            font-weight: bold;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #win98-content {
            flex: 1;
            background: #000000;
            border: 2px solid;
            border-color: #808080 #FFFFFF #FFFFFF #808080;
            margin: 3px;
            position: relative;
            overflow: hidden;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100% !important;
            height: 100% !important;
            display: block;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 5px;
            z-index: 100;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
        }
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
        }
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
        }
        #loadingScreen h2 {
            margin-bottom: 20px;
            font-size: 28px;
        }
        #progressBarContainer {
            width: 400px;
            height: 30px;
            background: #333;
            border: 2px solid #666;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 10px;
        }
        #progressBar {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            width: 0%;
            transition: width 0.3s;
        }
        #loadingText {
            margin-top: 15px;
            font-size: 16px;
            color: #aaa;
        }
        #loadingPercent {
            font-size: 24px;
            font-weight: bold;
            color: #FFD700;
            margin-top: 10px;
        }
        #hotbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border-radius: 5px;
            z-index: 100;
        }
        .hotbar-slot {
            width: 50px;
            height: 50px;
            border: 2px solid #555;
            background: rgba(139, 139, 139, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            position: relative;
            text-shadow: 1px 1px 2px black;
        }
        .hotbar-slot.active {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.2);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        .hotbar-slot:hover {
            border-color: #888;
        }
        .slot-number {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 10px;
            color: #ddd;
        }
        #titleScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #008080;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            color: white;
        }
        #titleScreen h1 {
            font-size: 48px;
            margin-bottom: 40px;
            text-shadow: 2px 2px 0 #000000;
            color: #FFFFFF;
            font-family: 'MS Sans Serif', Tahoma, sans-serif;
            font-weight: bold;
        }
        .world-type-container {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
        }
        .world-type-btn {
            padding: 8px 20px;
            font-size: 14px;
            font-weight: bold;
            font-family: 'MS Sans Serif', Tahoma, sans-serif;
            border: 2px outset #C0C0C0;
            background: #C0C0C0;
            color: #000000;
            cursor: pointer;
            box-shadow: 1px 1px 0 #000000;
        }
        .world-type-btn:hover {
            background: #DFDFDF;
        }
        .world-type-btn:active {
            border-style: inset;
            box-shadow: inset 1px 1px 2px #000000;
        }
        .world-type-btn.selected {
            background: #000080;
            color: #FFFFFF;
            border: 2px inset #000080;
        }
        #startBtn {
            padding: 10px 40px;
            font-size: 16px;
            font-weight: bold;
            font-family: 'MS Sans Serif', Tahoma, sans-serif;
            border: 2px outset #C0C0C0;
            background: #C0C0C0;
            color: #000000;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 1px 1px 0 #000000;
        }
        #startBtn:hover {
            background: #DFDFDF;
        }
        #startBtn:active {
            border-style: inset;
            box-shadow: inset 1px 1px 2px #000000;
        }
        #healthBar {
            position: fixed;
            bottom: 80px;
            left: 20px;
            display: flex;
            gap: 4px;
            z-index: 100;
            background: rgba(192, 192, 192, 0.9);
            padding: 5px 10px;
            border: 2px solid;
            border-color: #FFFFFF #000000 #000000 #FFFFFF;
        }
        .heart, .food {
            width: 20px;
            height: 20px;
            font-size: 16px;
            margin: 0 2px;
        }
        #craftingMenu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 10px;
            border: 3px solid #8B4513;
            display: none;
            z-index: 500;
            color: white;
        }
        #craftingMenu.active {
            display: block;
        }
        #craftingMenu h2 {
            margin-top: 0;
            color: #FFD700;
        }
        .recipe {
            padding: 10px;
            margin: 5px 0;
            background: rgba(139, 69, 19, 0.3);
            border: 2px solid #8B4513;
            cursor: pointer;
            border-radius: 5px;
        }
        .recipe:hover {
            background: rgba(139, 69, 19, 0.5);
        }
        #settingsMenu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #C0C0C0;
            border: 3px solid;
            border-color: #FFFFFF #000000 #000000 #FFFFFF;
            padding: 20px;
            display: none;
            z-index: 1500;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: inset 1px 1px 0 #DFDFDF, inset -1px -1px 0 #808080;
        }
        #settingsMenu.active {
            display: block;
        }
        #settingsMenu h2 {
            background: linear-gradient(to right, #000080, #1084D0);
            color: white;
            padding: 4px 8px;
            margin: -20px -20px 20px -20px;
            font-weight: bold;
            font-size: 13px;
            font-family: 'MS Sans Serif', Tahoma, sans-serif;
        }
        .setting-item {
            margin: 15px 0;
            padding: 10px;
            background: #FFFFFF;
            border: 2px solid;
            border-color: #808080 #DFDFDF #DFDFDF #808080;
        }
        .setting-item label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            font-family: 'MS Sans Serif', Tahoma, sans-serif;
            font-size: 11px;
            color: #000000;
        }
        .setting-item input[type="range"] {
            width: 100%;
            cursor: pointer;
        }
        .setting-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        .setting-value {
            float: right;
            color: #000080;
            font-weight: bold;
        }
        .settings-btn {
            padding: 6px 16px;
            font-size: 13px;
            font-family: 'MS Sans Serif', Tahoma, sans-serif;
            font-weight: bold;
            background: #C0C0C0;
            color: #000000;
            border: 3px solid;
            border-color: #FFFFFF #000000 #000000 #FFFFFF;
            cursor: pointer;
            margin: 5px;
            width: calc(50% - 10px);
            box-shadow: inset 1px 1px 0 #DFDFDF, inset -1px -1px 0 #808080;
        }
        .settings-btn:hover {
            background: #DFDFDF;
        }
        .settings-btn:active {
            border-color: #000000 #FFFFFF #FFFFFF #000000;
            box-shadow: inset 1px 1px 0 #000000;
        }
        .settings-btn.close {
            background: #C0C0C0;
        }
        #inventoryMenu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(198, 198, 198, 0.98);
            padding: 8px;
            border: 0;
            border-radius: 0;
            z-index: 1000;
            display: none;
            box-shadow: 0 0 0 2px #000000;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #inventoryMenu h2 {
            color: #404040;
            margin: 8px 8px 16px 8px;
            font-family: 'Minecraftia', 'MS Sans Serif', monospace;
            font-size: 16px;
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.3);
        }
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(9, 54px);
            gap: 4px;
            padding: 8px;
            background: rgba(139, 139, 139, 0.8);
            border: 2px solid;
            border-color: #FFFFFF #555555 #555555 #FFFFFF;
        }
        .inventory-item {
            width: 48px;
            height: 48px;
            background: #8B8B8B;
            border: 2px solid;
            border-color: #373737 #FFFFFF #FFFFFF #373737;
            padding: 0;
            cursor: pointer;
            transition: none;
            position: relative;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        .inventory-item:hover {
            background: #AAAAAA;
            border-color: #555555 #EEEEEE #EEEEEE #555555;
        }
        .inventory-item.selected {
            background: #FFFFFF;
            border-color: #FFFF00 #FFFF00 #FFFF00 #FFFF00;
            border-width: 2px;
            box-shadow: inset 0 0 4px rgba(255, 255, 0, 0.5);
        }
        .inventory-item canvas {
            width: 48px;
            height: 48px;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            display: block;
        }
        .inventory-item span {
            display: none;
        }
        .inventory-tooltip {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 4px 8px;
            font-size: 11px;
            font-family: 'Minecraftia', monospace;
            white-space: nowrap;
            pointer-events: none;
            z-index: 10000;
            border: 1px solid #555;
            display: none;
        }
        .inventory-item:hover .inventory-tooltip {
            display: block;
        }
    </style>
</head>
<body>
    <div id="win98-frame">
        <div id="win98-titlebar">
            <span>⛏</span>
            Minecraft Nesa Explorer 5 Edition
        </div>
        <div id="win98-content">
    <div id="titleScreen">
        <h1>*** MINECRAFT NESA EXPLORER 5 ***</h1>
        <div class="world-type-container">
            <button class="world-type-btn" onclick="selectWorldType('normal')">Normal</button>
            <button class="world-type-btn" onclick="selectWorldType('snowy')">Snowy</button>
            <button class="world-type-btn" onclick="selectWorldType('desert')">Desert</button>
            <button class="world-type-btn" onclick="selectWorldType('extreme')">Extreme</button>
            <button class="world-type-btn" onclick="selectWorldType('flat')">Flat</button>
        </div>
        <button id="startBtn" onclick="startGame()">START GAME</button>
    </div>
    <div id="healthBar"></div>
    <div id="craftingMenu">
        <h2>Crafting</h2>
        <div class="recipe" onclick="craft('oak_planks')">4 Oak Planks <- 1 Oak Log</div>
        <div class="recipe" onclick="craft('stick')">4 Sticks <- 2 Oak Planks</div>
        <div class="recipe" onclick="craft('cobblestone')">Cobblestone <- Smelt Stone</div>
        <div class="recipe" onclick="craft('glass')">Glass <- Smelt Sand</div>
        <div class="recipe" onclick="craft('bricks')">Bricks <- 4 Clay (use dirt)</div>
        <p style="margin-top: 20px; color: #000;">Press 'C' to close</p>
    </div>
    <div id="settingsMenu">
        <h2>Settings</h2>
        <div class="setting-item">
            <label>Render Distance: <span class="setting-value" id="renderValue">1</span> chunks</label>
            <input type="range" id="renderDistance" min="1" max="4" value="1" step="1">
        </div>
        <div class="setting-item">
            <label>Field of View: <span class="setting-value" id="fovValue">75</span>°</label>
            <input type="range" id="fovSlider" min="60" max="110" value="75" step="5">
        </div>
        <div class="setting-item">
            <label>Mouse Sensitivity: <span class="setting-value" id="sensValue">0.002</span></label>
            <input type="range" id="sensitivity" min="0.001" max="0.005" value="0.002" step="0.0005">
        </div>
        <div class="setting-item">
            <label>Movement Speed: <span class="setting-value" id="speedValue">0.15</span></label>
            <input type="range" id="moveSpeed" min="0.05" max="0.5" value="0.15" step="0.05">
        </div>
        <div class="setting-item">
            <label>Third-Person Distance: <span class="setting-value" id="camDistValue">5</span></label>
            <input type="range" id="camDistance" min="3" max="10" value="5" step="1">
        </div>
        <div class="setting-item">
            <label><input type="checkbox" id="showFPS"> Show FPS Counter</label>
        </div>
        <div class="setting-item">
            <label><input type="checkbox" id="enableFog" checked> Enable Fog</label>
        </div>
        <div class="setting-item">
            <label><input type="checkbox" id="fastMode"> Fast Mode (720p, No Fog, 64 Block Render)</label>
        </div>
        <div style="text-align: center; margin-top: 20px;">
            <button class="settings-btn" onclick="applySettings()">Apply</button>
            <button class="settings-btn close" onclick="closeSettings()">Close</button>
        </div>
        <p style="margin-top: 20px; color: #aaa; text-align: center;">Press 'ESC' to close</p>
    </div>
    <div id="inventoryMenu">
        <h2>Inventory</h2>
        <div class="inventory-grid" id="inventoryGrid"></div>
        <p style="color: #404040; text-align: center; margin: 12px 8px 8px 8px; font-size: 11px; font-family: 'Minecraftia', monospace;">Press 'I' or ESC to close</p>
    </div>
    <div id="info">
        <h3>*** MINECRAFT NESA EXPLORER 5 ***</h3>
    </div>
    <div id="crosshair"></div>
    <div id="hotbar"></div>    
    <div id="loadingScreen">
        <h2>Generating World...</h2>
        <div id="progressBarContainer">
            <div id="progressBar"></div>
        </div>
        <div id="loadingPercent">0%</div>
        <div id="loadingText">Initializing terrain generation...</div>
    </div>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Game state
        let selectedWorldType = 'normal';
        let gameStarted = false;
        let playerHealth = 20;
        let playerVelocityY = 0;
        let isOnGround = false;
        let fallDistance = 0;
        let lastY = 0;
        const GRAVITY = 0; // Gravity disabled for flying
        const JUMP_STRENGTH = 0;
        const FLY_SPEED = 0.2; // Flying speed
        const mobs = []; // Mobs disabled
        let craftingOpen = false;
        let inventoryOpen = false;
        
        // Multiplayer
        let ws = null;
        let playerName = '';
        let otherPlayers = {};
        let isMultiplayer = false;
        
        // Camera mode
        let thirdPerson = false;
        let cameraDistance = 5;
        let playerMesh = null;
        
        // Settings
        let settingsOpen = false;
        let mouseSensitivity = 0.002;
        let moveSpeed = 0.15;
        let renderDistance = 1;
        let fov = 75;
        let showFPS = false;
        let enableFog = true;
        let fastMode = false;
        let frameCount = 0;
        let lastFpsTime = Date.now();
        let currentFps = 0;
        
        // Day/night cycle
        let timeOfDay = 6000;
        const dayLength = 20000;
        let sunLight = null;
        let moonLight = null;
        let ambientLight = null;
        
        // Animals
        const animals = [];
        const animalTypes = [
            { type: 'cow', color: 0x8B4513, size: 1.0 },
            { type: 'pig', color: 0xFFC0CB, size: 0.8 },
            { type: 'sheep', color: 0xFFFFFF, size: 0.9 },
            { type: 'chicken', color: 0xFFFFFF, size: 0.5 }
        ];
        
        // Title screen functions
        function selectWorldType(type) {
            selectedWorldType = type;
            document.querySelectorAll('.world-type-btn').forEach(btn => btn.classList.remove('selected'));
            event.target.classList.add('selected');
        }
        
        function startGame() {
            if (!selectedWorldType) {
                selectedWorldType = 'normal';
            }
            
            // Ask for nickname
            playerName = prompt('Enter your nickname:', 'Player' + Math.floor(Math.random() * 1000));
            if (!playerName) playerName = 'Player' + Math.floor(Math.random() * 1000);
            
            // Try to connect to multiplayer server
            connectMultiplayer();
            
            document.getElementById('titleScreen').style.display = 'none';
            gameStarted = true;
            initGame();
        }
        
        // Initialize health bar
        function initUI() {
            const healthBar = document.getElementById('healthBar');
            
            for (let i = 0; i < 10; i++) {
                const heart = document.createElement('div');
                heart.className = 'heart';
                heart.textContent = '<3';
                healthBar.appendChild(heart);
            }
            
            updateHealthBar();
        }
        
        function updateHealthBar() {
            const hearts = document.querySelectorAll('.heart');
            hearts.forEach((heart, i) => {
                heart.style.opacity = i < playerHealth / 2 ? '1' : '0.3';
            });
        }
        
        function craft(item) {
            // Simple crafting - just add to inventory
            alert(`Crafted ${item}!`);
            // In a full game, you'd check resources and add to inventory
        }
        
        function toggleCrafting() {
            craftingOpen = !craftingOpen;
            const menu = document.getElementById('craftingMenu');
            if (craftingOpen) {
                menu.classList.add('active');
            } else {
                menu.classList.remove('active');
            }
        }
        
        function toggleSettings() {
            settingsOpen = !settingsOpen;
            const menu = document.getElementById('settingsMenu');
            if (settingsOpen) {
                menu.classList.add('active');
                document.exitPointerLock();
                // Update sliders with current values
                document.getElementById('renderDistance').value = renderDistance;
                document.getElementById('renderValue').textContent = renderDistance;
                document.getElementById('fovSlider').value = fov;
                document.getElementById('fovValue').textContent = fov;
                document.getElementById('sensitivity').value = mouseSensitivity;
                document.getElementById('sensValue').textContent = mouseSensitivity;
                document.getElementById('moveSpeed').value = moveSpeed;
                document.getElementById('speedValue').textContent = moveSpeed;
                document.getElementById('camDistance').value = cameraDistance;
                document.getElementById('camDistValue').textContent = cameraDistance;
                document.getElementById('showFPS').checked = showFPS;
                document.getElementById('enableFog').checked = enableFog;
                document.getElementById('fastMode').checked = fastMode;
            } else {
                menu.classList.remove('active');
            }
        }
        
        function applySettings() {
            renderDistance = parseInt(document.getElementById('renderDistance').value);
            fov = parseInt(document.getElementById('fovSlider').value);
            mouseSensitivity = parseFloat(document.getElementById('sensitivity').value);
            moveSpeed = parseFloat(document.getElementById('moveSpeed').value);
            cameraDistance = parseInt(document.getElementById('camDistance').value);
            showFPS = document.getElementById('showFPS').checked;
            enableFog = document.getElementById('enableFog').checked;
            fastMode = document.getElementById('fastMode').checked;
            
            // Apply Fast Mode
            if (fastMode) {
                // Fast Mode: 720x480, no fog, 64 blocks render distance
                renderer.setSize(720, 480);
                camera.aspect = 720 / 480;
                camera.updateProjectionMatrix();
                scene.fog = null;
                enableFog = false;
                renderDistance = 4; // Maximum render distance (4 chunks = 64 blocks)
            } else {
                // Normal Mode: 480x360, fog enabled
                renderer.setSize(480, 360);
                camera.aspect = 480 / 360;
                camera.updateProjectionMatrix();
                if (enableFog) {
                    scene.fog = new THREE.Fog(0x99CCFF, 12, 24);
                }
            }
            
            // Apply camera FOV
            camera.fov = fov;
            camera.updateProjectionMatrix();
            
            // Update render distance
            updateChunks(camera.position.x, camera.position.z);
            
            alert('Settings applied! ✓');
        }
        
        function closeSettings() {
            settingsOpen = false;
            document.getElementById('settingsMenu').classList.remove('active');
        }
        
        function takeDamage(amount) {
            playerHealth = Math.max(0, playerHealth - amount);
            updateHealthBar();
            if (playerHealth <= 0) {
                alert('You died! Reloading...');
                location.reload();
            }
        }
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x99CCFF); // Beta sky
        scene.fog = new THREE.Fog(0x99CCFF, 12, 24);

        const camera = new THREE.PerspectiveCamera(75, 480 / 360, 0.1, 256);
        
        // Create player mesh (for third-person view)
        const playerGeometry = new THREE.BoxGeometry(0.8, 1.8, 0.8);
        const playerMaterial = new THREE.MeshLambertMaterial({ color: 0x00FF00 }); // Bright green
        playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
        playerMesh.visible = false; // Hidden in first-person
        playerMesh.castShadow = true;
        scene.add(playerMesh);
        console.log('Player mesh created:', playerMesh);
        
        // Particle system
        const particles = [];
        function createParticle(x, y, z, color) {
            const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true });
            const particle = new THREE.Mesh(geo, mat);
            particle.position.set(x, y, z);
            particle.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.2,
                Math.random() * 0.3,
                (Math.random() - 0.5) * 0.2
            );
            particle.life = 30;
            scene.add(particle);
            particles.push(particle);
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.velocity);
                p.velocity.y -= 0.01;
                p.life--;
                p.material.opacity = p.life / 30;
                if (p.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }
        }
        
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(480, 360);
        document.body.appendChild(renderer.domElement);

        // Lighting with day/night system
        ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        sunLight = new THREE.DirectionalLight(0xffffcc, 0.8);
        sunLight.position.set(50, 100, 50);
        scene.add(sunLight);
        
        moonLight = new THREE.DirectionalLight(0x8888ff, 0.2);
        moonLight.position.set(-50, 50, -50);
        moonLight.visible = false;
        scene.add(moonLight);

        // Texture loader
        const textureLoader = new THREE.TextureLoader();
        
        // Load actual block textures from textures directory
        function loadTexture(filename) {
            console.log(`Attempting to load: textures/${filename}`);
            const texture = textureLoader.load(`textures/${filename}`, 
                // Success callback
                (tex) => {
                    console.log(`✓ Successfully loaded: textures/${filename}`);
                    console.log('Texture size:', tex.image.width, 'x', tex.image.height);
                },
                // Progress callback
                undefined,
                // Error callback
                (err) => {
                    console.error(`✗ Failed to load: textures/${filename}`, err);
                }
            );
            texture.magFilter = THREE.LinearFilter;
            texture.minFilter = THREE.LinearFilter;
            return texture;
        }
        
        // Create textures that match Minecraft blocks
        function createBlockTexture(color) {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, 16, 16);
            
            // Add pixelated noise for texture
            for (let i = 0; i < 50; i++) {
                const x = Math.floor(Math.random() * 16);
                const y = Math.floor(Math.random() * 16);
                const brightness = Math.random() > 0.5 ? 20 : -20;
                ctx.fillStyle = adjustColor(color, brightness);
                ctx.fillRect(x, y, 1, 1);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.LinearFilter;
            texture.minFilter = THREE.LinearFilter;
            return texture;
        }
        
        function adjustColor(hex, amount) {
            const num = parseInt(hex.slice(1), 16);
            const r = Math.max(0, Math.min(255, ((num >> 16) & 0xff) + amount));
            const g = Math.max(0, Math.min(255, ((num >> 8) & 0xff) + amount));
            const b = Math.max(0, Math.min(255, (num & 0xff) + amount));
            return '#' + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
        }

        // Block types with textures - 23 blocks!
        const blockTypes = {
            // Block types matching provided textures
            grass: { 
                texture: loadTexture('grass_top.png'), 
                sideTexture: loadTexture('grass_side.png'),
                bottomTexture: loadTexture('dirt.png'),
                name: 'Grass' 
            },
            dirt: { texture: loadTexture('dirt.png'), name: 'Dirt' },
            stone: { texture: loadTexture('stone.png'), name: 'Stone' },
            cobblestone: { texture: loadTexture('cobblestone.png'), name: 'Cobblestone' },
            bedrock: { texture: loadTexture('bedrock.png'), name: 'Bedrock' },
            sand: { texture: loadTexture('sand.png'), name: 'Sand' },
            oak_log: { 
                texture: loadTexture('wood_side.png'),
                sideTexture: loadTexture('wood_side.png'),
                bottomTexture: loadTexture('wood_top.png'),
                name: 'Oak Log' 
            },
            oak_planks: { texture: loadTexture('oak_planks.png'), name: 'Oak Planks' },
            oak_leaves: { texture: loadTexture('leaves.png'), name: 'Oak Leaves' },
            gravel: { texture: loadTexture('gravel.png'), name: 'Gravel' },
            slab: { 
                texture: loadTexture('slab_side.png'),
                sideTexture: loadTexture('slab_side.png'),
                bottomTexture: loadTexture('slab_top.png'),
                name: 'Slab' 
            },
            bricks: { texture: loadTexture('bricks.png'), name: 'Bricks' },
            coal_ore: { texture: loadTexture('coal_ore.png'), name: 'Coal Ore' },
            iron_ore: { texture: loadTexture('iron_ore.png'), name: 'Iron Ore' },
            gold_ore: { texture: loadTexture('gold_ore.png'), name: 'Gold Ore' },
            diamond_ore: { texture: loadTexture('diamond_ore.png'), name: 'Diamond Ore' },
            glass: { texture: loadTexture('glass.png'), name: 'Glass' },
            ice: { texture: loadTexture('ice.png'), name: 'Ice' },
            snow: { texture: loadTexture('snow.png'), name: 'Snow' },
            water: { texture: loadTexture('water.png'), name: 'Water' },
            wool: { texture: loadTexture('wool.png'), name: 'Wool' },
            red_flower: { texture: loadTexture('red_flower.png'), name: 'Red Flower' },
            yellow_flower: { texture: loadTexture('yellow_flower.png'), name: 'Yellow Flower' }
        };

        // Create inventory array
        const allBlocks = Object.keys(blockTypes);
        let selectedBlockIndex = 0;
        let selectedBlock = allBlocks[0];
        let hotbarSlots = [];

        // Initialize hotbar with first 9 blocks
        function initHotbar() {
            const hotbarContainer = document.getElementById('hotbar');
            for (let i = 0; i < 9; i++) {
                const slot = document.createElement('div');
                slot.className = 'hotbar-slot';
                if (i === 0) slot.classList.add('active');
                slot.innerHTML = `<span class="slot-number">${i + 1}</span><span>${blockTypes[allBlocks[i]].name.substring(0, 8)}</span>`;
                slot.onclick = () => selectSlot(i);
                hotbarContainer.appendChild(slot);
                hotbarSlots.push(i);
            }
            populateInventory();
        }

        function populateInventory() {
            const inventoryGrid = document.getElementById('inventoryGrid');
            inventoryGrid.innerHTML = '';
            
            allBlocks.forEach((blockKey, index) => {
                const block = blockTypes[blockKey];
                const item = document.createElement('div');
                item.className = 'inventory-item';
                if (index === selectedBlockIndex) item.classList.add('selected');
                
                // Create mini canvas for texture preview
                const canvas = document.createElement('canvas');
                canvas.width = 48;
                canvas.height = 48;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                
                // Draw texture with pixelated rendering
                if (block.texture && block.texture.image && block.texture.image.complete) {
                    // Draw texture filling the entire canvas
                    ctx.drawImage(block.texture.image, 0, 0, 48, 48);
                } else {
                    // Placeholder while texture loads
                    ctx.fillStyle = '#8B8B8B';
                    ctx.fillRect(0, 0, 48, 48);
                    ctx.fillStyle = '#666';
                    ctx.fillRect(2, 2, 44, 44);
                }
                
                // Create tooltip
                const tooltip = document.createElement('div');
                tooltip.className = 'inventory-tooltip';
                tooltip.textContent = block.name;
                
                item.appendChild(canvas);
                item.appendChild(tooltip);
                item.onclick = () => selectBlockFromInventory(index);
                inventoryGrid.appendChild(item);
            });
        }

        function selectBlockFromInventory(index) {
            selectedBlockIndex = index;
            selectedBlock = allBlocks[selectedBlockIndex];
            updateInfo();
            populateInventory();
            
            // Update hotbar to center on selected block
            hotbarSlots = [];
            for (let i = 0; i < 9; i++) {
                let idx = (selectedBlockIndex - 4 + i + allBlocks.length) % allBlocks.length;
                hotbarSlots.push(idx);
            }
            
            const slots = document.querySelectorAll('.hotbar-slot');
            slots.forEach((slot, i) => {
                const blockIdx = hotbarSlots[i];
                const blockName = blockTypes[allBlocks[blockIdx]].name;
                slot.innerHTML = `<span class="slot-number">${i + 1}</span><span>${blockName.substring(0, 8)}</span>`;
                slot.classList.toggle('active', i === 4);
            });
        }

        function toggleInventory() {
            inventoryOpen = !inventoryOpen;
            const menu = document.getElementById('inventoryMenu');
            menu.style.display = inventoryOpen ? 'block' : 'none';
            if (inventoryOpen) {
                populateInventory();
                document.exitPointerLock();
            }
        }

        function selectSlot(index) {
            document.querySelectorAll('.hotbar-slot').forEach((slot, i) => {
                slot.classList.toggle('active', i === index);
            });
            selectedBlockIndex = hotbarSlots[index];
            selectedBlock = allBlocks[selectedBlockIndex];
            updateInfo();
        }

        function scrollBlocks(direction) {
            // Scroll through all blocks and update hotbar
            selectedBlockIndex += direction;
            if (selectedBlockIndex < 0) selectedBlockIndex = allBlocks.length - 1;
            if (selectedBlockIndex >= allBlocks.length) selectedBlockIndex = 0;
            selectedBlock = allBlocks[selectedBlockIndex];
            
            // Update hotbar slots
            hotbarSlots = [];
            for (let i = 0; i < 9; i++) {
                let idx = (selectedBlockIndex - 4 + i + allBlocks.length) % allBlocks.length;
                hotbarSlots.push(idx);
            }
            
            // Update hotbar UI
            const slots = document.querySelectorAll('.hotbar-slot');
            slots.forEach((slot, i) => {
                const blockIdx = hotbarSlots[i];
                const blockName = blockTypes[allBlocks[blockIdx]].name;
                slot.innerHTML = `<span class="slot-number">${i + 1}</span><span>${blockName.substring(0, 8)}</span>`;
                slot.classList.toggle('active', i === 4); // Center slot is active
            });
            
            updateInfo();
        }

        // Keyboard state
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            
            // Settings menu
            if (e.code === 'Escape') {
                e.preventDefault();
                if (inventoryOpen) {
                    toggleInventory();
                } else {
                    toggleSettings();
                }
            }
            
            // Crafting menu
            if (e.code === 'KeyC' && !settingsOpen) {
                toggleCrafting();
            }
            
            // Inventory menu
            if (e.code === 'KeyI' && !settingsOpen) {
                toggleInventory();
            }
            
            // Toggle camera view (F5)
            if (e.code === 'F5') {
                e.preventDefault();
                thirdPerson = !thirdPerson;
                if (playerMesh) {
                    playerMesh.visible = thirdPerson;
                    console.log('Third-person mode:', thirdPerson, 'Player mesh visible:', playerMesh.visible);
                }
            }
            
            // Hotbar selection
            if (e.code === 'Digit1') selectSlot(0);
            if (e.code === 'Digit2') selectSlot(1);
            if (e.code === 'Digit3') selectSlot(2);
            if (e.code === 'Digit4') selectSlot(3);
            if (e.code === 'Digit5') selectSlot(4);
            if (e.code === 'Digit6') selectSlot(5);
            if (e.code === 'Digit7') selectSlot(6);
            if (e.code === 'Digit8') selectSlot(7);
            if (e.code === 'Digit9') selectSlot(8);
            // Arrow keys to scroll blocks
            if (e.code === 'ArrowRight') scrollBlocks(1);
            if (e.code === 'ArrowLeft') scrollBlocks(-1);
        });
        document.addEventListener('keyup', (e) => keys[e.code] = false);

        // Mouse wheel to scroll blocks
        document.addEventListener('wheel', (e) => {
            if (isLocked) {
                e.preventDefault();
                scrollBlocks(e.deltaY > 0 ? 1 : -1);
            }
        });

        initHotbar();

        function updateInfo() {
            document.getElementById('info').innerHTML = `
                <h3>⛏️ Minecraft Nesa Explorer 5 ⛏️</h3>
                <p><strong>Click to start</strong><br>
                WASD: Move<br>
                Mouse: Look<br>
                Space: Fly Up<br>
                Shift: Fly Down<br>
                I: Inventory<br>
                1-9: Hotbar slots<br>
                Mouse Wheel / ←→: Scroll blocks<br>
                Left Click: Break<br>
                Right Click: Place<br>
                <strong style="color: #FFD700;">Block: ${blockTypes[selectedBlock].name} (${selectedBlockIndex + 1}/${allBlocks.length})</strong><br>
                <em>World: 1024x1024 Beta Terrain</em></p>
            `;
        }
        updateInfo();

        // Mouse controls
        let pitch = 0, yaw = 0;
        let isLocked = false;
        let justLocked = false;

        renderer.domElement.addEventListener('click', (e) => {
            if (!isLocked) {
                e.preventDefault();
                e.stopPropagation();
                renderer.domElement.requestPointerLock();
                justLocked = true;
                setTimeout(() => justLocked = false, 500);
            }
        });

        document.addEventListener('pointerlockchange', () => {
            isLocked = document.pointerLockElement === renderer.domElement;
        });

        document.addEventListener('mousemove', (e) => {
            if (!isLocked) return;
            yaw -= e.movementX * 0.002;
            pitch -= e.movementY * 0.002;
            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
        });

        // Raycaster for block placement/breaking
        const raycaster = new THREE.Raycaster();
        raycaster.far = 8;

        document.addEventListener('mousedown', (e) => {
            if (!isLocked || justLocked) return;
            
            const direction = new THREE.Vector3(0, 0, -1);
            direction.applyQuaternion(camera.quaternion);
            
            raycaster.set(camera.position, direction);
            
            const allMeshes = [];
            for (const chunkKey in chunks) {
                chunks[chunkKey].children.forEach(mesh => {
                    allMeshes.push(mesh);
                    // Add child meshes recursively if any
                    if (mesh.children && mesh.children.length > 0) {
                        mesh.children.forEach(child => allMeshes.push(child));
                    }
                });
            }
            
            const intersects = raycaster.intersectObjects(allMeshes, true);
            
            if (intersects.length > 0) {
                const intersect = intersects[0];
                const hitPoint = intersect.point;
                const normal = intersect.face.normal;
                
                if (e.button === 0) {
                    // Left click - break block
                    const blockX = Math.floor(hitPoint.x + normal.x * 0.001);
                    const blockY = Math.floor(hitPoint.y + normal.y * 0.001);
                    const blockZ = Math.floor(hitPoint.z + normal.z * 0.001);
                    
                    const key = `${blockX},${blockY},${blockZ}`;
                    const blockType = getBlockType(blockX, blockY, blockZ);
                    world[key] = null;
                    regenerateChunk(blockX, blockZ);
                    
                    // Create break particles
                    const blockColors = {
                        'grass': 0x7CFC00, 'dirt': 0x8B4513, 'stone': 0x808080,
                        'coal_ore': 0x333333, 'iron_ore': 0xC77B00, 
                        'gold_ore': 0xFFD700, 'diamond_ore': 0x00FFFF
                    };
                    const color = blockColors[blockType] || 0x8B4513;
                    for (let i = 0; i < 8; i++) {
                        createParticle(
                            blockX + Math.random(),
                            blockY + Math.random(), 
                            blockZ + Math.random(),
                            color
                        );
                    }
                    
                    // Send to multiplayer
                    sendBlockChange(blockX, blockY, blockZ, null);
                    
                } else if (e.button === 2) {
                    // Right click - place block
                    const blockX = Math.floor(hitPoint.x - normal.x * 0.001);
                    const blockY = Math.floor(hitPoint.y - normal.y * 0.001);
                    const blockZ = Math.floor(hitPoint.z - normal.z * 0.001);
                    
                    const newX = blockX + Math.sign(normal.x);
                    const newY = blockY + Math.sign(normal.y);
                    const newZ = blockZ + Math.sign(normal.z);
                    
                    const key = `${newX},${newY},${newZ}`;
                    if (!getBlockType(newX, newY, newZ)) {
                        world[key] = selectedBlock;
                        regenerateChunk(newX, newZ);
                        
                        // Send to multiplayer
                        sendBlockChange(newX, newY, newZ, selectedBlock);
                    }
                }
            }
        });

        document.addEventListener('contextmenu', (e) => e.preventDefault());

        // Perlin noise for beta-like terrain
        const blockSize = 1;
        const worldSize = 512; // 1024x1024 world (-512 to 512)
        const waterLevel = 32;
        const maxHeight = 96; // Tall mountains!

        function hash(x, z, seed = 0) {
            let h = seed + x * 374761393 + z * 668265263;
            h = (h ^ (h >> 13)) * 1274126177;
            return (h ^ (h >> 16)) / 2147483648.0;
        }

        function noise2D(x, z) {
            const x0 = Math.floor(x), z0 = Math.floor(z);
            const x1 = x0 + 1, z1 = z0 + 1;
            const fx = x - x0, fz = z - z0;
            const sx = fx * fx * (3 - 2 * fx);
            const sz = fz * fz * (3 - 2 * fz);
            
            const n00 = hash(x0, z0);
            const n10 = hash(x1, z0);
            const n01 = hash(x0, z1);
            const n11 = hash(x1, z1);
            
            const nx0 = n00 + sx * (n10 - n00);
            const nx1 = n01 + sx * (n11 - n01);
            return nx0 + sz * (nx1 - nx0);
        }

        function fractalNoise(x, z, octaves) {
            let total = 0;
            let amplitude = 1;
            let maxValue = 0;
            for (let i = 0; i < octaves; i++) {
                total += noise2D(x * (0.01 * Math.pow(2, i)), z * (0.01 * Math.pow(2, i))) * amplitude;
                maxValue += amplitude;
                amplitude *= 0.5;
            }
            return total / maxValue;
        }

        const world = {};
        const chunks = {}; // Store chunk meshes
        const CHUNK_SIZE = 16;
        const RENDER_DISTANCE = 1; // chunks (1 * 16 = 16 blocks)

        // Get chunk key
        function getChunkKey(x, z) {
            const cx = Math.floor(x / CHUNK_SIZE);
            const cz = Math.floor(z / CHUNK_SIZE);
            return `${cx},${cz}`;
        }

        // Generate heightmap data (no meshes yet)
        const heightMap = {};
        const treePositions = {};
        const lakePositions = {}; // Water lakes
        const flowerPositions = {}; // Flower decorations
        const buildings = [];
        
        function generateHeightMap() {
            let treeCount = 0;
            let lakeCount = 0;
            let flowerCount = 0;
            
            console.log(`Generating ${selectedWorldType} world...`);
            
            let processed = 0;
            const totalBlocks = (worldSize * 2 + 1) * (worldSize * 2 + 1);
            
            for (let x = -worldSize; x <= worldSize; x++) {
                for (let z = -worldSize; z <= worldSize; z++) {
                    processed++;
                    let height;
                    
                    if (selectedWorldType === 'flat') {
                        // Flat world at y=32
                        height = waterLevel;
                    } else if (selectedWorldType === 'extreme') {
                        // Extreme mountains - VERY tall
                        const continentalness = fractalNoise(x * 0.3, z * 0.3, 3) * 0.5 + 0.5;
                        const peaksValleys = fractalNoise(x * 1.5, z * 1.5, 5);
                        const mountainHeight = Math.pow(continentalness, 1.2) * 200;
                        const peakDetail = peaksValleys * 40;
                        height = Math.floor(waterLevel + mountainHeight + peakDetail);
                        height = Math.min(height, 250); // Cap at 250 for extreme
                    } else {
                        // Normal, snowy, desert - rolling hills
                        const continentalness = fractalNoise(x * 0.5, z * 0.5, 2) * 0.5 + 0.5;
                        const erosion = fractalNoise(x, z, 3) * 0.5 + 0.5;
                        const peaksValleys = fractalNoise(x * 2, z * 2, 4);
                        
                        if (continentalness > 0.6) {
                            // Hills
                            const hillHeight = (continentalness - 0.6) * 80;
                            const hillDetail = peaksValleys * 15;
                            height = Math.floor(waterLevel + 8 + hillHeight + hillDetail);
                        } else {
                            // Plains
                            const plainHeight = fractalNoise(x * 0.8, z * 0.8, 2) * 6;
                            height = Math.floor(waterLevel + 2 + plainHeight);
                        }
                        
                        // Trees for normal world only
                        if (selectedWorldType === 'normal' && height > waterLevel && Math.random() < 0.02) {
                            treePositions[`${x},${z}`] = true;
                            treeCount++;
                        }
                        
                        // Flowers for normal world
                        if (selectedWorldType === 'normal' && height > waterLevel && Math.random() < 0.03) {
                            flowerPositions[`${x},${z}`] = Math.random() < 0.5 ? 'red_flower' : 'yellow_flower';
                            flowerCount++;
                        }
                    }
                    
                    height = Math.max(0, Math.min(maxHeight, height));
                    heightMap[`${x},${z}`] = height;
                    
                    // Update progress every 5%
                    if (processed % Math.floor(totalBlocks / 20) === 0) {
                        const progress = Math.floor((processed / totalBlocks) * 100);
                        document.getElementById('loadingPercent').innerText = progress + '%';
                        document.getElementById('progressBar').style.width = progress + '%';
                        document.getElementById('loadingText').innerText = `Generating ${selectedWorldType} world... (${progress}%)`;
                    }
                }
            }
            console.log(`Generated ${treeCount} trees, ${flowerCount} flowers`);
        }

        // Get terrain height at position
        function getTerrainHeight(x, z) {
            const key = `${Math.floor(x)},${Math.floor(z)}`;
            return heightMap[key] || waterLevel;
        }
        
        // Get block type at position
        function getBlockType(x, y, z) {
            // Check if manually placed/removed first
            const blockKey = `${x},${y},${z}`;
            if (world.hasOwnProperty(blockKey)) {
                return world[blockKey]; // Returns the block type or null if removed
            }
            
            const key = `${x},${z}`;
            const height = heightMap[key];
            
            // Check for water lakes
            if (lakePositions[key] && y <= height && y >= height - 2 && height > waterLevel) {
                if (y === height) return null; // Air above water
                return 'water'; // Water in lake
            }
            
            if (height === undefined || y > height) return null;
            
            // Spawn platform (5x5 cobblestone with ice border)
            const spawnX = 0, spawnZ = 0;
            if (x >= spawnX - 2 && x <= spawnX + 2 && z >= spawnZ - 2 && z <= spawnZ + 2 && y === waterLevel) {
                // Ice border, cobblestone center
                if (x === spawnX - 2 || x === spawnX + 2 || z === spawnZ - 2 || z === spawnZ + 2) {
                    return 'ice';
                } else {
                    return 'cobblestone';
                }
            }
            
            // Generate block type based on height and world type
            if (y === 0) {
                return 'bedrock'; // Bedrock layer
            } else if (y === height && height > waterLevel) {
                // Surface block depends on world type
                if (selectedWorldType === 'snowy') {
                    return 'snow';
                } else if (selectedWorldType === 'desert') {
                    return 'sand';
                } else {
                    return 'grass'; // Normal/Extreme/Flat
                }
            } else if (y > height - 4 && height > waterLevel) {
                // Sub-surface
                if (selectedWorldType === 'desert') {
                    return 'sand';
                } else {
                    return 'dirt';
                }
            } else if (y > height - 2 && height <= waterLevel) {
                return 'dirt'; // Less dirt underwater
            } else {
                // Underground - stone with ores
                const oreRand = Math.random();
                const depth = height - y;
                
                if (depth > 40 && oreRand < 0.001) {
                    return 'diamond_ore'; // Very rare, deep
                }
                else if (depth > 25 && oreRand < 0.005) {
                    return 'gold_ore'; // Rare, medium-deep
                }
                else if (depth > 15 && oreRand < 0.015) {
                    return 'iron_ore'; // Uncommon, medium depth
                }
                else if (depth > 5 && oreRand < 0.04) {
                    return 'coal_ore'; // Common, any depth
                }
                
                return 'stone'; // Default stone
            }
        }

        // Generate chunk mesh with merged geometry
        function generateChunk(chunkX, chunkZ) {
            const chunkKey = `${chunkX},${chunkZ}`;
            if (chunks[chunkKey]) return; // Already generated
            
            const geometries = {};
            
            // Collect all blocks in chunk
            for (let localX = 0; localX < CHUNK_SIZE; localX++) {
                for (let localZ = 0; localZ < CHUNK_SIZE; localZ++) {
                    const x = chunkX * CHUNK_SIZE + localX;
                    const z = chunkZ * CHUNK_SIZE + localZ;
                    
                    if (x < -worldSize || x > worldSize || z < -worldSize || z > worldSize) continue;
                    
                    const heightKey = `${x},${z}`;
                    const height = heightMap[heightKey] || 0;
                    
                    for (let y = 0; y <= Math.max(height, maxHeight); y++) {
                        const blockType = getBlockType(x, y, z);
                        if (!blockType) continue;
                        
                        // Check if block is exposed (has at least one visible face)
                        const isExposed = 
                            !getBlockType(x + 1, y, z) ||
                            !getBlockType(x - 1, y, z) ||
                            !getBlockType(x, y + 1, z) ||
                            !getBlockType(x, y - 1, z) ||
                            !getBlockType(x, y, z + 1) ||
                            !getBlockType(x, y, z - 1);
                        
                        if (isExposed) {
                            // Apply face culling to all blocks for better performance
                            const specialKey = blockType + '_culled';
                            if (!geometries[specialKey]) geometries[specialKey] = [];
                            
                            // Check each face individually
                            const faces = [];
                            
                            // Right face (+X)
                            if (!getBlockType(x + 1, y, z)) {
                                faces.push({ dir: 'right', normal: [1, 0, 0] });
                            }
                            // Left face (-X)
                            if (!getBlockType(x - 1, y, z)) {
                                faces.push({ dir: 'left', normal: [-1, 0, 0] });
                            }
                            // Top face (+Y)
                            if (!getBlockType(x, y + 1, z)) {
                                faces.push({ dir: 'top', normal: [0, 1, 0] });
                            }
                            // Bottom face (-Y)
                            if (!getBlockType(x, y - 1, z)) {
                                faces.push({ dir: 'bottom', normal: [0, -1, 0] });
                            }
                            // Front face (+Z)
                            if (!getBlockType(x, y, z + 1)) {
                                faces.push({ dir: 'front', normal: [0, 0, 1] });
                            }
                            // Back face (-Z)
                            if (!getBlockType(x, y, z - 1)) {
                                faces.push({ dir: 'back', normal: [0, 0, -1] });
                            }
                            
                            // Create geometry for each visible face
                            faces.forEach(face => {
                                const geo = new THREE.PlaneGeometry(1, 1);
                                
                                // Position and rotate plane based on face direction
                                if (face.dir === 'right') {
                                    geo.rotateY(Math.PI / 2);
                                    geo.translate(x + 0.5, y, z);
                                } else if (face.dir === 'left') {
                                    geo.rotateY(-Math.PI / 2);
                                    geo.translate(x - 0.5, y, z);
                                } else if (face.dir === 'top') {
                                    geo.rotateX(-Math.PI / 2);
                                    geo.translate(x, y + 0.5, z);
                                } else if (face.dir === 'bottom') {
                                    geo.rotateX(Math.PI / 2);
                                    geo.translate(x, y - 0.5, z);
                                } else if (face.dir === 'front') {
                                    geo.translate(x, y, z + 0.5);
                                } else if (face.dir === 'back') {
                                    geo.rotateY(Math.PI);
                                    geo.translate(x, y, z - 0.5);
                                }
                                
                                // Determine texture based on face and block type
                                let texture;
                                if (blockType === 'grass' || blockType === 'oak_log' || blockType === 'slab') {
                                    // Multi-texture blocks
                                    if (face.dir === 'top') {
                                        texture = blockTypes[blockType].texture;
                                    } else if (face.dir === 'bottom') {
                                        texture = blockTypes[blockType].bottomTexture || blockTypes[blockType].texture;
                                    } else {
                                        texture = blockTypes[blockType].sideTexture || blockTypes[blockType].texture;
                                    }
                                } else {
                                    // Single texture blocks
                                    texture = blockTypes[blockType].texture;
                                }
                                
                                const mat = new THREE.MeshLambertMaterial({ map: texture });
                                const mesh = new THREE.Mesh(geo, mat);
                                geometries[specialKey].push(mesh);
                            });
                        }
                    }
                    
                    // Water
                    if (height < waterLevel && !world[`${x},${waterLevel},${z}`]) {
                        if (!geometries['water']) geometries['water'] = [];
                        const geo = new THREE.BoxGeometry(1, 1, 1);
                        geo.translate(x, waterLevel, z);
                        geometries['water'].push(geo);
                    }
                    
                    // Flowers on grass
                    const flowerKey = `${x},${z}`;
                    if (flowerPositions[flowerKey] && height > waterLevel) {
                        const flowerType = flowerPositions[flowerKey];
                        const flowerY = height + 1;
                        
                        if (!getBlockType(x, flowerY, z)) {
                            if (!geometries[flowerType]) geometries[flowerType] = [];
                            const geo = new THREE.BoxGeometry(0.3, 0.6, 0.3);
                            geo.translate(x, flowerY, z);
                            geometries[flowerType].push(geo);
                        }
                    }
                }
            }
            
            // Generate trees in this chunk
            for (const treeKey in treePositions) {
                const [tx, tz] = treeKey.split(',').map(Number);
                
                // Check if tree is in this chunk
                if (tx >= chunkX * CHUNK_SIZE && tx < (chunkX + 1) * CHUNK_SIZE &&
                    tz >= chunkZ * CHUNK_SIZE && tz < (chunkZ + 1) * CHUNK_SIZE) {
                    
                    const treeGroundHeight = heightMap[`${tx},${tz}`] || 0;
                    
                    if (treeGroundHeight > waterLevel && treeGroundHeight < maxHeight - 10) {
                        const treeHeight = 6 + Math.floor(Math.random() * 3);
                        const trunkTop = treeGroundHeight + treeHeight;
                        
                        // Tree trunk
                        for (let ty = treeGroundHeight + 1; ty <= trunkTop; ty++) {
                            if (!geometries['oak_log']) geometries['oak_log'] = [];
                            const geo = new THREE.BoxGeometry(1, 1, 1);
                            geo.translate(tx, ty, tz);
                            geometries['oak_log'].push(geo);
                        }
                        
                        // Leaves
                        for (let lx = -2; lx <= 2; lx++) {
                            for (let lz = -2; lz <= 2; lz++) {
                                for (let ly = -1; ly <= 2; ly++) {
                                    const leafY = trunkTop + ly;
                                    if (leafY <= maxHeight && !(lx === 0 && lz === 0 && ly < 0)) {
                                        if (!geometries['oak_leaves']) geometries['oak_leaves'] = [];
                                        const geo = new THREE.BoxGeometry(1, 1, 1);
                                        geo.translate(tx + lx, leafY, tz + lz);
                                        geometries['oak_leaves'].push(geo);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Generate buildings in this chunk
            for (const building of buildings) {
                const bx = building.x;
                const bz = building.z;
                const bw = building.width;
                const bl = building.length;
                const bh = building.height;
                
                // Check if building overlaps this chunk
                if (bx - bw/2 < (chunkX + 1) * CHUNK_SIZE && bx + bw/2 >= chunkX * CHUNK_SIZE &&
                    bz - bl/2 < (chunkZ + 1) * CHUNK_SIZE && bz + bl/2 >= chunkZ * CHUNK_SIZE) {
                    
                    const buildingGroundHeight = heightMap[`${bx},${bz}`] || waterLevel + 1;
                    
                    if (buildingGroundHeight > waterLevel) {
                        for (let bxx = Math.floor(bx - bw/2); bxx <= Math.floor(bx + bw/2); bxx++) {
                            for (let bzz = Math.floor(bz - bl/2); bzz <= Math.floor(bz + bl/2); bzz++) {
                                // Check if block is in current chunk
                                if (bxx >= chunkX * CHUNK_SIZE && bxx < (chunkX + 1) * CHUNK_SIZE &&
                                    bzz >= chunkZ * CHUNK_SIZE && bzz < (chunkZ + 1) * CHUNK_SIZE) {
                                    
                                    const isWall = bxx === Math.floor(bx - bw/2) || bxx === Math.floor(bx + bw/2) ||
                                                   bzz === Math.floor(bz - bl/2) || bzz === Math.floor(bz + bl/2);
                                    
                                    for (let byy = buildingGroundHeight + 1; byy <= buildingGroundHeight + bh; byy++) {
                                        const isRoof = byy === buildingGroundHeight + bh;
                                        
                                        if (isWall || isRoof) {
                                            let blockType = 'oak_planks';
                                            if (building.type === 'tower') blockType = 'stone';
                                            if (isRoof) blockType = 'oak_planks';
                                            
                                            if (!geometries[blockType]) geometries[blockType] = [];
                                            const geo = new THREE.BoxGeometry(1, 1, 1);
                                            geo.translate(bxx, byy, bzz);
                                            geometries[blockType].push(geo);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Merge geometries per block type
            const chunkGroup = new THREE.Group();
            for (const blockType in geometries) {
                if (geometries[blockType].length === 0) continue;
                
                // All blocks now use face culling (ending with _culled)
                if (blockType.endsWith('_culled')) {
                    geometries[blockType].forEach(mesh => chunkGroup.add(mesh));
                } else {
                    // Trees and other non-culled blocks
                    const mergedGeo = mergeGeometries(geometries[blockType]);
                    
                    const originalBlockType = blockType.replace('_culled', '');
                    const isTransparent = originalBlockType === 'water' || originalBlockType === 'glass' || originalBlockType === 'ice';
                    const isFlower = originalBlockType === 'red_flower' || originalBlockType === 'yellow_flower';
                    
                    const mat = new THREE.MeshLambertMaterial({ 
                        map: blockTypes[originalBlockType]?.texture || blockTypes[originalBlockType],
                        transparent: isTransparent || isFlower,
                        opacity: isTransparent ? 0.7 : 1,
                        alphaTest: isFlower ? 0.5 : 0,
                        side: isFlower ? THREE.DoubleSide : THREE.FrontSide
                    });
                    
                    const mesh = new THREE.Mesh(mergedGeo, mat);
                    chunkGroup.add(mesh);
                }
            }
            
            scene.add(chunkGroup);
            chunks[chunkKey] = chunkGroup;
        }

        // Regenerate chunk after block changes
        function regenerateChunk(x, z) {
            const chunkX = Math.floor(x / CHUNK_SIZE);
            const chunkZ = Math.floor(z / CHUNK_SIZE);
            const chunkKey = `${chunkX},${chunkZ}`;
            
            // Remove old chunk
            if (chunks[chunkKey]) {
                scene.remove(chunks[chunkKey]);
                delete chunks[chunkKey];
            }
            
            // Generate new chunk
            generateChunk(chunkX, chunkZ);
        }

        // Fallback merge function if BufferGeometryUtils not available
        function mergeGeometries(geometries) {
            const merged = new THREE.BufferGeometry();
            const positions = [];
            const normals = [];
            const uvs = [];
            const indices = [];
            let indexOffset = 0;
            
            geometries.forEach(geo => {
                const pos = geo.attributes.position.array;
                const norm = geo.attributes.normal.array;
                const uv = geo.attributes.uv.array;
                const idx = geo.index ? geo.index.array : null;
                
                // Add positions
                for (let i = 0; i < pos.length; i++) positions.push(pos[i]);
                
                // Add normals
                for (let i = 0; i < norm.length; i++) normals.push(norm[i]);
                
                // Add UVs
                for (let i = 0; i < uv.length; i++) uvs.push(uv[i]);
                
                // Add indices with offset
                if (idx) {
                    for (let i = 0; i < idx.length; i++) {
                        indices.push(idx[i] + indexOffset);
                    }
                    indexOffset += pos.length / 3;
                } else {
                    // No indices, create them
                    for (let i = 0; i < pos.length / 3; i++) {
                        indices.push(indexOffset + i);
                    }
                    indexOffset += pos.length / 3;
                }
            });
            
            merged.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            merged.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            merged.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            merged.setIndex(indices);
            
            return merged;
        }

        // Unload distant chunks
        function updateChunks(playerX, playerZ) {
            const playerChunkX = Math.floor(playerX / CHUNK_SIZE);
            const playerChunkZ = Math.floor(playerZ / CHUNK_SIZE);
            
            // Generate nearby chunks
            for (let cx = playerChunkX - RENDER_DISTANCE; cx <= playerChunkX + RENDER_DISTANCE; cx++) {
                for (let cz = playerChunkZ - RENDER_DISTANCE; cz <= playerChunkZ + RENDER_DISTANCE; cz++) {
                    generateChunk(cx, cz);
                }
            }
            
            // Unload far chunks
            for (const chunkKey in chunks) {
                const [cx, cz] = chunkKey.split(',').map(Number);
                const dist = Math.max(Math.abs(cx - playerChunkX), Math.abs(cz - playerChunkZ));
                
                if (dist > RENDER_DISTANCE + 1) {
                    scene.remove(chunks[chunkKey]);
                    delete chunks[chunkKey];
                }
            }
        }

        // Generate terrain with progress bar
        async function generateTerrain() {
            const progressBar = document.getElementById('progressBar');
            const progressPercent = document.getElementById('loadingPercent');
            const loadingText = document.getElementById('loadingText');

            loadingText.textContent = 'Generating height map...';
            generateHeightMap();
            
            progressBar.style.width = '50%';
            progressPercent.textContent = '50%';
            await new Promise(resolve => setTimeout(resolve, 100));
            
            loadingText.textContent = 'Loading initial chunks...';
            updateChunks(0, 0);
            
            progressBar.style.width = '100%';
            progressPercent.textContent = '100%';
            loadingText.textContent = 'World ready! Click to start...';
            await new Promise(resolve => setTimeout(resolve, 500));
            document.getElementById('loadingScreen').style.display = 'none';
        }
        
        // Mob functions
        function createMob(type) {
            const mob = {
                type: type,
                health: 10,
                x: camera.position.x + (Math.random() - 0.5) * 50,
                z: camera.position.z + (Math.random() - 0.5) * 50,
                y: 40,
                mesh: null
            };
            
            // Create mob mesh
            const geometry = new THREE.BoxGeometry(0.8, 1.8, 0.8);
            const material = new THREE.MeshLambertMaterial({
                color: type === 'zombie' ? 0x00FF00 : 0xFFFFFF
            });
            mob.mesh = new THREE.Mesh(geometry, material);
            mob.mesh.position.set(mob.x, mob.y, mob.z);
            scene.add(mob.mesh);
            
            return mob;
        }
        
        function spawnMobs() {
            // Spawn 5-10 mobs around player
            const mobCount = 5 + Math.floor(Math.random() * 5);
            for (let i = 0; i < mobCount; i++) {
                const type = Math.random() < 0.5 ? 'zombie' : 'skeleton';
                mobs.push(createMob(type));
            }
            console.log(`Spawned ${mobCount} mobs`);
        }
        
        // Animal functions
        function createAnimal(animalType) {
            const animal = {
                type: animalType.type,
                x: camera.position.x + (Math.random() - 0.5) * 40,
                z: camera.position.z + (Math.random() - 0.5) * 40,
                y: 40,
                vx: (Math.random() - 0.5) * 0.02,
                vz: (Math.random() - 0.5) * 0.02,
                mesh: null
            };
            
            const geometry = new THREE.BoxGeometry(animalType.size, animalType.size * 0.8, animalType.size);
            const material = new THREE.MeshLambertMaterial({ color: animalType.color });
            animal.mesh = new THREE.Mesh(geometry, material);
            animal.mesh.position.set(animal.x, animal.y, animal.z);
            scene.add(animal.mesh);
            
            return animal;
        }
        
        function spawnAnimals() {
            const animalCount = 8 + Math.floor(Math.random() * 8);
            for (let i = 0; i < animalCount; i++) {
                const type = animalTypes[Math.floor(Math.random() * animalTypes.length)];
                animals.push(createAnimal(type));
            }
            console.log(`Spawned ${animalCount} animals`);
        }
        
        function updateAnimals() {
            animals.forEach(animal => {
                if (Math.random() < 0.02) {
                    animal.vx = (Math.random() - 0.5) * 0.04;
                    animal.vz = (Math.random() - 0.5) * 0.04;
                }
                
                animal.x += animal.vx;
                animal.z += animal.vz;
                
                const groundHeight = getTerrainHeight(animal.x, animal.z) + 0.5;
                animal.y = groundHeight;
                
                if (animal.mesh) {
                    animal.mesh.position.set(animal.x, animal.y, animal.z);
                }
            });
        }
        
        function updateMobs() {
            mobs.forEach((mob, index) => {
                // Move toward player
                const dx = camera.position.x - mob.x;
                const dz = camera.position.z - mob.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance > 2 && distance < 50) {
                    const speed = 0.05;
                    mob.x += (dx / distance) * speed;
                    mob.z += (dz / distance) * speed;
                    
                    // Update mob position
                    if (mob.mesh) {
                        mob.mesh.position.x = mob.x;
                        mob.mesh.position.z = mob.z;
                    }
                }
                
                // Check collision with player
                if (distance < 1.5) {
                    takeDamage(1);
                    // Knock mob back
                    mob.x -= (dx / distance) * 2;
                    mob.z -= (dz / distance) * 2;
                }
                
                // Remove dead mobs
                if (mob.health <= 0) {
                    scene.remove(mob.mesh);
                    mobs.splice(index, 1);
                }
            });
        }
        
        // Initialize game
        function initGame() {
            initUI();
            generateTerrain().then(() => {
                spawnAnimals();
                // Flying mode enabled - no gravity, no mobs
            });
        }
        
        // Multiplayer functions
        function connectMultiplayer() {
            try {
                ws = new WebSocket('ws://localhost:8765');
                
                ws.onopen = () => {
                    console.log('Connected to multiplayer server!');
                    isMultiplayer = true;
                    // Send join message
                    ws.send(JSON.stringify({
                        type: 'join',
                        name: playerName,
                        worldType: selectedWorldType
                    }));
                };
                
                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    
                    if (data.type === 'playerUpdate') {
                        updateOtherPlayer(data.id, data.position, data.rotation, data.name);
                    } else if (data.type === 'playerLeft') {
                        removeOtherPlayer(data.id);
                    } else if (data.type === 'blockChange') {
                        // Update block from other player
                        const key = `${data.x},${data.y},${data.z}`;
                        world[key] = data.blockType;
                        regenerateChunk(data.x, data.z);
                    }
                };
                
                ws.onerror = () => {
                    console.log('Multiplayer server not available - playing solo');
                    isMultiplayer = false;
                };
                
                ws.onclose = () => {
                    console.log('Disconnected from multiplayer server');
                    isMultiplayer = false;
                };
            } catch (e) {
                console.log('Could not connect to multiplayer server');
                isMultiplayer = false;
            }
        }
        
        function sendPlayerUpdate() {
            if (isMultiplayer && ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'playerUpdate',
                    position: {
                        x: camera.position.x,
                        y: camera.position.y,
                        z: camera.position.z
                    },
                    rotation: {
                        yaw: yaw,
                        pitch: pitch
                    }
                }));
            }
        }
        
        function sendBlockChange(x, y, z, blockType) {
            if (isMultiplayer && ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'blockChange',
                    x: x,
                    y: y,
                    z: z,
                    blockType: blockType
                }));
            }
        }
        
        function updateOtherPlayer(id, position, rotation, name) {
            if (!otherPlayers[id]) {
                // Create new player
                const geometry = new THREE.BoxGeometry(0.8, 1.8, 0.8);
                const material = new THREE.MeshLambertMaterial({ color: 0x0088FF });
                const mesh = new THREE.Mesh(geometry, material);
                
                // Add name label
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                ctx.fillStyle = 'white';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(name, 128, 48);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(2, 0.5, 1);
                sprite.position.y = 1.5;
                mesh.add(sprite);
                
                scene.add(mesh);
                otherPlayers[id] = { mesh: mesh, name: name };
            }
            
            // Update player position
            if (otherPlayers[id]) {
                otherPlayers[id].mesh.position.set(position.x, position.y, position.z);
                otherPlayers[id].mesh.rotation.y = rotation.yaw;
            }
        }
        
        function removeOtherPlayer(id) {
            if (otherPlayers[id]) {
                scene.remove(otherPlayers[id].mesh);
                delete otherPlayers[id];
            }
        }

        // Player (flying)
        camera.position.set(0, 40, 0); // Spawn close to ground
        let lastChunkUpdate = { x: 0, z: 0 };

        // Game loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (!gameStarted) return; // Don't update before game starts

            // Update camera rotation
            camera.quaternion.setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
            
            // Update player mesh position
            if (playerMesh && thirdPerson) {
                playerMesh.position.copy(camera.position);
                playerMesh.position.y -= 0.9; // Center at feet
                playerMesh.rotation.y = yaw;
                playerMesh.visible = true; // Ensure it's visible
            }

            // Movement
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
            
            forward.y = 0;
            right.y = 0;
            forward.normalize();
            right.normalize();

            if (keys.KeyW) camera.position.add(forward.multiplyScalar(moveSpeed));
            if (keys.KeyS) camera.position.add(forward.multiplyScalar(-moveSpeed));
            if (keys.KeyA) camera.position.add(right.multiplyScalar(-moveSpeed));
            if (keys.KeyD) camera.position.add(right.multiplyScalar(moveSpeed));
            
            // FPS Counter
            if (showFPS) {
                frameCount++;
                const now = Date.now();
                if (now - lastFpsTime >= 1000) {
                    currentFps = frameCount;
                    frameCount = 0;
                    lastFpsTime = now;
                    const info = document.getElementById('info');
                    if (info && info.querySelector('h3')) {
                        info.querySelector('h3').textContent = `*** MINECRAFT NESA EXPLORER 5 *** | FPS: ${currentFps}`;
                    }
                }
            }
            
            // Flying mode - no gravity
            // Fly up with Space
            if (keys.Space) {
                camera.position.y += FLY_SPEED;
            }
            
            // Fly down with Shift
            if (keys.ShiftLeft || keys.ShiftRight) {
                camera.position.y -= FLY_SPEED;
            }
            
            // Keep player above minimum height
            const groundHeight = getTerrainHeight(camera.position.x, camera.position.z) + 1.7;
            if (camera.position.y < groundHeight) {
                camera.position.y = groundHeight;
            }

            // Update chunks when player moves significantly
            const chunkX = Math.floor(camera.position.x / CHUNK_SIZE);
            const chunkZ = Math.floor(camera.position.z / CHUNK_SIZE);
            if (chunkX !== lastChunkUpdate.x || chunkZ !== lastChunkUpdate.z) {
                updateChunks(camera.position.x, camera.position.z);
                lastChunkUpdate = { x: chunkX, z: chunkZ };
            }
            
            // Mobs disabled
            
            // Update animals
            updateAnimals();
            
            // Update particles
            updateParticles();
            
            // Day/night cycle
            timeOfDay = (timeOfDay + 1) % 24000;
            
            if (timeOfDay < 6000) { // Night
                const nightProgress = timeOfDay / 6000;
                scene.background = new THREE.Color().setHSL(0.6, 0.5, 0.05 + nightProgress * 0.45);
                ambientLight.intensity = 0.2 + nightProgress * 0.4;
                sunLight.visible = false;
                moonLight.visible = true;
            } else if (timeOfDay < 18000) { // Day
                scene.background = new THREE.Color(0x99CCFF);
                ambientLight.intensity = 0.6;
                sunLight.visible = true;
                moonLight.visible = false;
                
                const sunProgress = (timeOfDay - 6000) / 12000;
                const sunAngle = sunProgress * Math.PI;
                sunLight.position.set(
                    Math.cos(sunAngle) * 100,
                    Math.sin(sunAngle) * 100,
                    50
                );
            } else { // Sunset
                const duskProgress = (timeOfDay - 18000) / 6000;
                scene.background = new THREE.Color().setHSL(0.08, 0.8, 0.5 - duskProgress * 0.45);
                ambientLight.intensity = 0.6 - duskProgress * 0.4;
                sunLight.visible = true;
                sunLight.intensity = 0.8 - duskProgress * 0.8;
                moonLight.visible = false;
            }
            
            // Render with camera positioning
            if (thirdPerson && playerMesh) {
                // Calculate camera offset behind player
                const cameraOffset = new THREE.Vector3(0, 2, 5); // 5 units back, 2 units up
                cameraOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
                
                const targetPos = new THREE.Vector3(
                    camera.position.x + cameraOffset.x,
                    camera.position.y + cameraOffset.y,
                    camera.position.z + cameraOffset.z
                );
                
                // Save original camera position
                const originalPos = camera.position.clone();
                const originalRot = camera.rotation.clone();
                
                // Move camera to third-person position
                camera.position.copy(targetPos);
                camera.lookAt(originalPos.x, originalPos.y + 0.5, originalPos.z);
                
                // Render scene
                renderer.render(scene, camera);
                
                // Restore camera
                camera.position.copy(originalPos);
                camera.rotation.copy(originalRot);
            } else {
                renderer.render(scene, camera);
            }
            
            // Send player position to other players (every 3 frames)
            if (gameStarted && isMultiplayer) {
                if (Math.random() < 0.33) {
                    sendPlayerUpdate();
                }
            }
        }

        animate();

        // Fixed 720x480 resolution - no resize needed
    </script>
</body>
</html>
