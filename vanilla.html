<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minecraft Nesa Explorer 5 Edition</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, sans-serif;
            background: linear-gradient(180deg, #4682B4 0%, #1E3A5F 100%);
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #win98-frame {
            width: 1280px;
            height: 720px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(255, 255, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            border-radius: 8px;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }
        #win98-titlebar {
            background: linear-gradient(180deg, rgba(185, 209, 234, 0.9) 0%, rgba(51, 94, 168, 0.9) 50%, rgba(43, 82, 150, 0.9) 51%, rgba(28, 58, 112, 0.9) 100%);
            color: white;
            padding: 8px 12px;
            font-weight: 600;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        #win98-content {
            flex: 1;
            background: #000000;
            border: 1px solid rgba(0, 0, 0, 0.3);
            margin: 0;
            position: relative;
            overflow: hidden;
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100% !important;
            height: 100% !important;
            display: block;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 5px;
            z-index: 100;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 20px;
            height: 20px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 100;
        }
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: white;
        }
        #crosshair::before {
            width: 2px;
            height: 20px;
            left: 9px;
        }
        #crosshair::after {
            width: 20px;
            height: 2px;
            top: 9px;
        }
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            color: white;
        }
        #loadingScreen h2 {
            margin-bottom: 20px;
            font-size: 28px;
        }
        #progressBarContainer {
            width: 400px;
            height: 30px;
            background: #333;
            border: 2px solid #666;
            border-radius: 5px;
            overflow: hidden;
            margin-top: 10px;
        }
        #progressBar {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            width: 0%;
            transition: width 0.3s;
        }
        #loadingText {
            margin-top: 15px;
            font-size: 16px;
            color: #aaa;
        }
        #loadingPercent {
            font-size: 24px;
            font-weight: bold;
            color: #FFD700;
            margin-top: 10px;
        }
        #hotbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 4px;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border-radius: 5px;
            z-index: 100;
        }
        .hotbar-slot {
            width: 50px;
            height: 50px;
            border: 2px solid #555;
            background: rgba(139, 139, 139, 0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            position: relative;
            text-shadow: 1px 1px 2px black;
        }
        .hotbar-slot.active {
            border-color: #FFD700;
            background: rgba(255, 215, 0, 0.2);
            box-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        .hotbar-slot:hover {
            border-color: #888;
        }
        .slot-number {
            position: absolute;
            top: 2px;
            left: 4px;
            font-size: 10px;
            color: #ddd;
        }
        #titleScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(180deg, #4682B4 0%, #1E3A5F 100%);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 2000;
            color: white;
            overflow-y: auto;
            padding: 40px 20px;
        }
        #titleScreen h1 {
            font-size: 56px;
            margin-bottom: 40px;
            text-shadow: 0 4px 8px rgba(0, 0, 0, 0.7);
            color: #FFFFFF;
            font-family: 'Segoe UI', Tahoma, sans-serif;
            font-weight: 300;
            letter-spacing: 2px;
        }
        .world-type-container {
            display: flex;
            gap: 20px;
            margin-bottom: 30px;
        }
        .world-type-btn {
            padding: 10px 24px;
            font-size: 14px;
            font-weight: 500;
            font-family: 'Segoe UI', Tahoma, sans-serif;
            border: 1px solid rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            background: linear-gradient(180deg, rgba(255, 255, 255, 0.9) 0%, rgba(230, 240, 255, 0.9) 50%, rgba(210, 230, 255, 0.9) 51%, rgba(200, 220, 245, 0.9) 100%);
            color: #1a1a1a;
            cursor: pointer;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.8);
            transition: all 0.2s ease;
            text-shadow: 0 1px 0 rgba(255, 255, 255, 0.7);
        }
        .world-type-btn:hover {
            background: linear-gradient(180deg, rgba(255, 255, 255, 1) 0%, rgba(240, 250, 255, 1) 50%, rgba(220, 240, 255, 1) 51%, rgba(210, 235, 255, 1) 100%);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.9);
        }
        .world-type-btn:active {
            background: linear-gradient(180deg, rgba(200, 220, 240, 0.9) 0%, rgba(220, 235, 250, 0.9) 100%);
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3), 0 1px 2px rgba(0, 0, 0, 0.2);
            transform: translateY(1px);
        }
        .world-type-btn.selected {
            background: linear-gradient(180deg, rgba(100, 150, 230, 0.95) 0%, rgba(70, 130, 210, 0.95) 50%, rgba(50, 110, 190, 0.95) 51%, rgba(40, 90, 170, 0.95) 100%);
            color: #FFFFFF;
            border: 1px solid rgba(20, 50, 100, 0.5);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.3);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.7);
        }
        #startBtn {
            padding: 14px 50px;
            font-size: 18px;
            font-weight: 600;
            font-family: 'Segoe UI', Tahoma, sans-serif;
            border: 1px solid rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            background: linear-gradient(180deg, rgba(120, 190, 120, 0.95) 0%, rgba(90, 170, 90, 0.95) 50%, rgba(70, 150, 70, 0.95) 51%, rgba(60, 130, 60, 0.95) 100%);
            color: #FFFFFF;
            cursor: pointer;
            margin-top: 30px;
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.4), inset 0 1px 0 rgba(255, 255, 255, 0.4);
            transition: all 0.2s ease;
            text-shadow: 0 2px 3px rgba(0, 0, 0, 0.5);
        }
        #startBtn:hover {
            background: linear-gradient(180deg, rgba(140, 210, 140, 0.95) 0%, rgba(110, 190, 110, 0.95) 50%, rgba(90, 170, 90, 0.95) 51%, rgba(80, 150, 80, 0.95) 100%);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5), inset 0 1px 0 rgba(255, 255, 255, 0.5);
            transform: translateY(-1px);
        }
        #startBtn:active {
            background: linear-gradient(180deg, rgba(60, 130, 60, 0.95) 0%, rgba(80, 150, 80, 0.95) 100%);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.4), 0 1px 3px rgba(0, 0, 0, 0.3);
            transform: translateY(1px);
        }
        #healthBar {
            position: fixed;
            bottom: 80px;
            left: 20px;
            display: flex;
            gap: 4px;
            z-index: 100;
            background: rgba(192, 192, 192, 0.9);
            padding: 5px 10px;
            border: 2px solid;
            border-color: #FFFFFF #000000 #000000 #FFFFFF;
        }
        .heart, .food {
            width: 20px;
            height: 20px;
            font-size: 16px;
            margin: 0 2px;
        }
        #craftingMenu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 30px;
            border-radius: 10px;
            border: 3px solid #8B4513;
            display: none;
            z-index: 500;
            color: white;
        }
        #craftingMenu.active {
            display: block;
        }
        #craftingMenu h2 {
            margin-top: 0;
            color: #FFD700;
        }
        .recipe {
            padding: 10px;
            margin: 5px 0;
            background: rgba(139, 69, 19, 0.3);
            border: 2px solid #8B4513;
            cursor: pointer;
            border-radius: 5px;
        }
        .recipe:hover {
            background: rgba(139, 69, 19, 0.5);
        }
        #settingsMenu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #C0C0C0;
            border: 3px solid;
            border-color: #FFFFFF #000000 #000000 #FFFFFF;
            padding: 20px;
            display: none;
            z-index: 1500;
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: inset 1px 1px 0 #DFDFDF, inset -1px -1px 0 #808080;
        }
        #settingsMenu.active {
            display: block;
        }
        #settingsMenu h2 {
            background: linear-gradient(to right, #000080, #1084D0);
            color: white;
            padding: 4px 8px;
            margin: -20px -20px 20px -20px;
            font-weight: bold;
            font-size: 13px;
            font-family: 'MS Sans Serif', Tahoma, sans-serif;
        }
        .setting-item {
            margin: 15px 0;
            padding: 10px;
            background: #FFFFFF;
            border: 2px solid;
            border-color: #808080 #DFDFDF #DFDFDF #808080;
        }
        .setting-item label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            font-family: 'MS Sans Serif', Tahoma, sans-serif;
            font-size: 11px;
            color: #000000;
        }
        .setting-item input[type="range"] {
            width: 100%;
            cursor: pointer;
        }
        .setting-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }
        .setting-value {
            float: right;
            color: #000080;
            font-weight: bold;
        }
        .settings-btn {
            padding: 6px 16px;
            font-size: 13px;
            font-family: 'MS Sans Serif', Tahoma, sans-serif;
            font-weight: bold;
            background: #C0C0C0;
            color: #000000;
            border: 3px solid;
            border-color: #FFFFFF #000000 #000000 #FFFFFF;
            cursor: pointer;
            margin: 5px;
            width: calc(50% - 10px);
            box-shadow: inset 1px 1px 0 #DFDFDF, inset -1px -1px 0 #808080;
        }
        .settings-btn:hover {
            background: #DFDFDF;
        }
        .settings-btn:active {
            border-color: #000000 #FFFFFF #FFFFFF #000000;
            box-shadow: inset 1px 1px 0 #000000;
        }
        .settings-btn.close {
            background: #C0C0C0;
        }
        #inventoryMenu {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            transform: none;
            background: rgba(198, 198, 198, 0.98);
            padding: 20px;
            border: 0;
            border-radius: 0;
            z-index: 1000;
            display: none;
            box-shadow: none;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            overflow-y: auto;
        }
        #inventoryMenu h2 {
            color: #404040;
            margin: 12px 12px 16px 12px;
            font-family: 'Minecraftia', 'MS Sans Serif', monospace;
            font-size: 18px;
            text-shadow: 2px 2px 0px rgba(0, 0, 0, 0.3);
            text-align: center;
        }
        .inventory-grid {
            display: grid;
            grid-template-columns: repeat(10, 64px);
            gap: 6px;
            padding: 12px;
            background: rgba(139, 139, 139, 0.8);
            border: 2px solid;
            border-color: #FFFFFF #555555 #555555 #FFFFFF;
            max-width: 700px;
            margin: 0 auto;
        }
        .inventory-item {
            width: 56px;
            height: 56px;
            background: #8B8B8B;
            border: 2px solid;
            border-color: #373737 #FFFFFF #FFFFFF #373737;
            padding: 0;
            cursor: pointer;
            transition: none;
            position: relative;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        .inventory-item:hover {
            background: #AAAAAA;
            border-color: #555555 #EEEEEE #EEEEEE #555555;
        }
        .inventory-item.selected {
            background: #FFFFFF;
            border-color: #FFFF00 #FFFF00 #FFFF00 #FFFF00;
            border-width: 2px;
            box-shadow: inset 0 0 4px rgba(255, 255, 0, 0.5);
        }
        .inventory-item canvas {
            width: 56px;
            height: 56px;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            display: block;
        }
        .inventory-item span {
            display: none;
        }
        .inventory-tooltip {
            position: absolute;
            bottom: -30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 4px 8px;
            font-size: 11px;
            font-family: 'Minecraftia', monospace;
            white-space: nowrap;
            pointer-events: none;
            z-index: 10000;
            border: 1px solid #555;
            display: none;
        }
        .inventory-item:hover .inventory-tooltip {
            display: block;
        }
    </style>
</head>
<body>
    <div id="win98-frame">
        <div id="win98-titlebar">
            <span>⛏</span>
            Minecraft Nesa Explorer 5 Edition
        </div>
        <div id="win98-content">
    <div id="titleScreen">
        <h1>*** MINECRAFT NESA EXPLORER 5 ***</h1>
        <div class="world-type-container">
            <button class="world-type-btn" onclick="selectWorldType('normal')">Normal</button>
            <button class="world-type-btn" onclick="selectWorldType('snowy')">Snowy</button>
            <button class="world-type-btn" onclick="selectWorldType('desert')">Desert</button>
            <button class="world-type-btn" onclick="selectWorldType('extreme')">Extreme</button>
            <button class="world-type-btn" onclick="selectWorldType('flat')">Flat</button>
        </div>
        <div class="world-type-container" style="margin-top: 20px;">
            <button class="world-type-btn" onclick="setResolution(1280, 720)">720p HD</button>
            <button class="world-type-btn" onclick="setResolution(1920, 1080)" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); font-weight: bold;">1080p ULTRA</button>
        </div>
        <button id="startBtn" onclick="startGame()">START GAME</button>
    </div>
    <div id="healthBar"></div>
    <div id="craftingMenu">
        <h2>Crafting</h2>
        <div class="recipe" onclick="craft('oak_planks')">4 Oak Planks <- 1 Oak Log</div>
        <div class="recipe" onclick="craft('stick')">4 Sticks <- 2 Oak Planks</div>
        <div class="recipe" onclick="craft('cobblestone')">Cobblestone <- Smelt Stone</div>
        <div class="recipe" onclick="craft('glass')">Glass <- Smelt Sand</div>
        <div class="recipe" onclick="craft('bricks')">Bricks <- 4 Clay (use dirt)</div>
        <p style="margin-top: 20px; color: #000;">Press 'C' to close</p>
    </div>
    <div id="settingsMenu">
        <h2>Settings</h2>
        <div class="setting-item">
            <label>Render Distance: <span class="setting-value" id="renderValue">1</span> chunks</label>
            <input type="range" id="renderDistance" min="1" max="4" value="1" step="1">
        </div>
        <div class="setting-item">
            <label>Field of View: <span class="setting-value" id="fovValue">75</span>°</label>
            <input type="range" id="fovSlider" min="60" max="110" value="75" step="5">
        </div>
        <div class="setting-item">
            <label>Mouse Sensitivity: <span class="setting-value" id="sensValue">0.002</span></label>
            <input type="range" id="sensitivity" min="0.001" max="0.005" value="0.002" step="0.0005">
        </div>
        <div class="setting-item">
            <label>Movement Speed: <span class="setting-value" id="speedValue">0.15</span></label>
            <input type="range" id="moveSpeed" min="0.05" max="0.5" value="0.15" step="0.05">
        </div>
        <div class="setting-item">
            <label>Third-Person Distance: <span class="setting-value" id="camDistValue">5</span></label>
            <input type="range" id="camDistance" min="3" max="10" value="5" step="1">
        </div>
        <div class="setting-item">
            <label><input type="checkbox" id="showFPS"> Show FPS Counter</label>
        </div>
        <div class="setting-item">
            <label><input type="checkbox" id="enableFog" checked> Enable Fog</label>
        </div>
        <div class="setting-item">
            <label><input type="checkbox" id="fastMode"> Fast Mode (720p, No Fog, 64 Block Render)</label>
        </div>
        <div style="text-align: center; margin-top: 20px;">
            <button class="settings-btn" onclick="applySettings()">Apply</button>
            <button class="settings-btn close" onclick="closeSettings()">Close</button>
        </div>
        <p style="margin-top: 20px; color: #aaa; text-align: center;">Press 'ESC' to close</p>
    </div>
    <div id="inventoryMenu">
        <h2>Inventory</h2>
        <div class="inventory-grid" id="inventoryGrid"></div>
        <p style="color: #404040; text-align: center; margin: 12px 8px 8px 8px; font-size: 11px; font-family: 'Minecraftia', monospace;">Press 'I' or ESC to close</p>
    </div>
    <div id="info">
        <h3>*** MINECRAFT NESA EXPLORER 5 ***</h3>
        <p id="multiplayerStatus" style="color: #FFD700; font-size: 14px; margin: 5px 0 0 0; font-family: 'Segoe UI', sans-serif;">Multiplayer: Connecting...</p>
    </div>
    <div id="crosshair"></div>
    <div id="hotbar"></div>    
    <div id="loadingScreen">
        <h2>Generating World...</h2>
        <div id="progressBarContainer">
            <div id="progressBar"></div>
        </div>
        <div id="loadingPercent">0%</div>
        <div id="loadingText">Initializing terrain generation...</div>
    </div>
        </div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // Multiplayer setup with WebSocket
        let socket = null;
        let myPlayerId = null;
        
        // Detect environment and use appropriate WebSocket URL
        const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
        const wsHost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1' 
            ? 'localhost:8000' 
            : window.location.host;
        const wsUrl = `${wsProtocol}//${wsHost}/ws/game/`;
        
        try {
            console.log('Connecting to:', wsUrl);
            socket = new WebSocket(wsUrl);
            
            socket.onopen = () => {
                console.log('Multiplayer enabled');
                const statusEl = document.getElementById('multiplayerStatus');
                if (statusEl) statusEl.textContent = 'Multiplayer: ENABLED ✓';
                if (statusEl) statusEl.style.color = '#00FF00';
            };
            
            socket.onerror = () => {
                console.log('Multiplayer connection failed');
                const statusEl = document.getElementById('multiplayerStatus');
                if (statusEl) statusEl.textContent = 'Multiplayer: DISABLED (Server offline)';
                if (statusEl) statusEl.style.color = '#FF6666';
                socket = null;
            };
            
            socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                console.log('[WEBSOCKET] Received:', data.type, data);
                handleMultiplayerMessage(data);
            };
        } catch(e) {
            console.log('Multiplayer disabled:', e);
            const statusEl = document.getElementById('multiplayerStatus');
            if (statusEl) statusEl.textContent = 'Multiplayer: DISABLED';
            if (statusEl) statusEl.style.color = '#FF6666';
        }
        
        function sendMultiplayer(data) {
            if (socket && socket.readyState === WebSocket.OPEN) {
                console.log('[WEBSOCKET] Sending:', data.type, data);
                socket.send(JSON.stringify(data));
            } else {
                console.log('[WEBSOCKET] Cannot send, socket not ready:', socket ? socket.readyState : 'null');
            }
        }
        
        // Game state
        let worldSeed = 0; // Will be set by server for multiplayer sync
        let pendingBlocks = null; // Store blocks until terrain is generated
        let selectedWorldType = 'normal';
        let gameStarted = false;
        let playerHealth = 20;
        let playerVelocityY = 0;
        let isOnGround = false;
        let fallDistance = 0;
        let lastY = 0;
        const GRAVITY = 0; // Gravity disabled for flying
        const JUMP_STRENGTH = 0;
        const FLY_SPEED = 0.2; // Flying speed
        const mobs = []; // Mobs disabled
        let craftingOpen = false;
        let inventoryOpen = false;
        
        // Multiplayer
        let otherPlayers = {};
        
        // Camera mode
        let thirdPerson = false;
        let cameraDistance = 5;
        let playerMesh = null;
        
        // Settings
        let settingsOpen = false;
        let mouseSensitivity = 0.002;
        let moveSpeed = 0.15;
        let renderDistance = 1;
        let fov = 75;
        let showFPS = false;
        let enableFog = true;
        let fastMode = false;
        let frameCount = 0;
        let lastFpsTime = Date.now();
        let currentFps = 0;
        
        // Resolution settings
        let gameWidth = 1280;
        let gameHeight = 720;
        
        // Day/night cycle
        let timeOfDay = 6000;
        const dayLength = 20000;
        let sunLight = null;
        let moonLight = null;
        let ambientLight = null;
        
        // Animals
        const animals = [];
        const animalTypes = [
            { type: 'cow', color: 0x8B4513, size: 1.0 },
            { type: 'pig', color: 0xFFC0CB, size: 0.8 },
            { type: 'sheep', color: 0xFFFFFF, size: 0.9 },
            { type: 'chicken', color: 0xFFFFFF, size: 0.5 }
        ];
        
        // Resolution selection
        function setResolution(width, height) {
            gameWidth = width;
            gameHeight = height;
            const frame = document.getElementById('win98-frame');
            frame.style.width = width + 'px';
            frame.style.height = height + 'px';
            
            // Highlight selected resolution button
            document.querySelectorAll('.world-type-container')[1].querySelectorAll('button').forEach(btn => {
                btn.style.transform = 'scale(1)';
            });
            event.target.style.transform = 'scale(1.05)';
        }
        
        // Title screen functions
        function selectWorldType(type) {
            selectedWorldType = type;
            document.querySelectorAll('.world-type-btn').forEach(btn => btn.classList.remove('selected'));
            event.target.classList.add('selected');
        }
        
        function startGame() {
            if (!selectedWorldType) {
                selectedWorldType = 'normal';
            }
            
            // Ask for nickname
            playerName = prompt('Enter your nickname:', 'Player' + Math.floor(Math.random() * 1000));
            if (!playerName) playerName = 'Player' + Math.floor(Math.random() * 1000);
            
            document.getElementById('titleScreen').style.display = 'none';
            gameStarted = true;
            initGame();
        }
        
        // Initialize health bar
        function initUI() {
            const healthBar = document.getElementById('healthBar');
            
            for (let i = 0; i < 10; i++) {
                const heart = document.createElement('div');
                heart.className = 'heart';
                heart.textContent = '<3';
                healthBar.appendChild(heart);
            }
            
            updateHealthBar();
        }
        
        function updateHealthBar() {
            const hearts = document.querySelectorAll('.heart');
            hearts.forEach((heart, i) => {
                heart.style.opacity = i < playerHealth / 2 ? '1' : '0.3';
            });
        }
        
        function craft(item) {
            // Simple crafting - just add to inventory
            alert(`Crafted ${item}!`);
            // In a full game, you'd check resources and add to inventory
        }
        
        function toggleCrafting() {
            craftingOpen = !craftingOpen;
            const menu = document.getElementById('craftingMenu');
            if (craftingOpen) {
                menu.classList.add('active');
            } else {
                menu.classList.remove('active');
            }
        }
        
        function toggleSettings() {
            settingsOpen = !settingsOpen;
            const menu = document.getElementById('settingsMenu');
            if (settingsOpen) {
                menu.classList.add('active');
                document.exitPointerLock();
                // Update sliders with current values
                document.getElementById('renderDistance').value = renderDistance;
                document.getElementById('renderValue').textContent = renderDistance;
                document.getElementById('fovSlider').value = fov;
                document.getElementById('fovValue').textContent = fov;
                document.getElementById('sensitivity').value = mouseSensitivity;
                document.getElementById('sensValue').textContent = mouseSensitivity;
                document.getElementById('moveSpeed').value = moveSpeed;
                document.getElementById('speedValue').textContent = moveSpeed;
                document.getElementById('camDistance').value = cameraDistance;
                document.getElementById('camDistValue').textContent = cameraDistance;
                document.getElementById('showFPS').checked = showFPS;
                document.getElementById('enableFog').checked = enableFog;
                document.getElementById('fastMode').checked = fastMode;
            } else {
                menu.classList.remove('active');
            }
        }
        
        function applySettings() {
            renderDistance = parseInt(document.getElementById('renderDistance').value);
            fov = parseInt(document.getElementById('fovSlider').value);
            mouseSensitivity = parseFloat(document.getElementById('sensitivity').value);
            moveSpeed = parseFloat(document.getElementById('moveSpeed').value);
            cameraDistance = parseInt(document.getElementById('camDistance').value);
            showFPS = document.getElementById('showFPS').checked;
            enableFog = document.getElementById('enableFog').checked;
            fastMode = document.getElementById('fastMode').checked;
            
            // Apply Fast Mode
            if (fastMode) {
                // Fast Mode: 720x480, no fog, 64 blocks render distance
                renderer.setSize(720, 480);
                camera.aspect = 720 / 480;
                camera.updateProjectionMatrix();
                scene.fog = null;
                enableFog = false;
                renderDistance = 4; // Maximum render distance (4 chunks = 64 blocks)
            } else {
                // Normal Mode: 480x360, fog enabled
                renderer.setSize(480, 360);
                camera.aspect = 480 / 360;
                camera.updateProjectionMatrix();
                if (enableFog) {
                    scene.fog = new THREE.Fog(0x99CCFF, 16, 32);
                }
            }
            
            // Apply camera FOV
            camera.fov = fov;
            camera.updateProjectionMatrix();
            
            // Update render distance
            updateChunks(camera.position.x, camera.position.z);
            
            alert('Settings applied! ✓');
        }
        
        function closeSettings() {
            settingsOpen = false;
            document.getElementById('settingsMenu').classList.remove('active');
        }
        
        function takeDamage(amount) {
            playerHealth = Math.max(0, playerHealth - amount);
            updateHealthBar();
            if (playerHealth <= 0) {
                alert('You died! Reloading...');
                location.reload();
            }
        }
        
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x99CCFF); // Beta sky
        scene.fog = new THREE.Fog(0x99CCFF, 16, 32);

        const camera = new THREE.PerspectiveCamera(75, gameWidth / gameHeight, 0.1, 256);
        
        // Create player mesh (for third-person view)
        const playerGeometry = new THREE.BoxGeometry(0.8, 1.8, 0.8);
        const playerMaterial = new THREE.MeshLambertMaterial({ color: 0x00FF00 }); // Bright green
        playerMesh = new THREE.Mesh(playerGeometry, playerMaterial);
        playerMesh.visible = false; // Hidden in first-person
        playerMesh.castShadow = true;
        scene.add(playerMesh);
        console.log('Player mesh created:', playerMesh);
        
        // Particle system
        const particles = [];
        function createParticle(x, y, z, color) {
            const geo = new THREE.BoxGeometry(0.1, 0.1, 0.1);
            const mat = new THREE.MeshBasicMaterial({ color: color, transparent: true });
            const particle = new THREE.Mesh(geo, mat);
            particle.position.set(x, y, z);
            particle.velocity = new THREE.Vector3(
                (Math.random() - 0.5) * 0.2,
                Math.random() * 0.3,
                (Math.random() - 0.5) * 0.2
            );
            particle.life = 30;
            scene.add(particle);
            particles.push(particle);
        }
        
        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                p.position.add(p.velocity);
                p.velocity.y -= 0.01;
                p.life--;
                p.material.opacity = p.life / 30;
                if (p.life <= 0) {
                    scene.remove(p);
                    particles.splice(i, 1);
                }
            }
        }
        
        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: 'high-performance' });
        renderer.setSize(gameWidth, gameHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // Limit for performance
        renderer.sortObjects = false; // Disable sorting for performance
        
        // Multiplayer message handler
        function handleMultiplayerMessage(data) {
            if (data.type === 'player_id') {
                myPlayerId = data.id;
                worldSeed = data.worldSeed || 0; // Use server's world seed
                console.log('My player ID:', myPlayerId);
                console.log('World seed:', worldSeed);
            }
            else if (data.type === 'currentPlayers') {
                Object.keys(data.players).forEach(id => {
                    if (id !== myPlayerId) {
                        addOtherPlayer(id, data.players[id]);
                    }
                });
            }
            else if (data.type === 'existingBlocks') {
                // Store blocks to load after terrain generation
                console.log('Received existing blocks:', Object.keys(data.blocks).length);
                pendingBlocks = data.blocks;
            }
            else if (data.type === 'playerJoined') {
                if (data.player.id !== myPlayerId) {
                    addOtherPlayer(data.player.id, data.player);
                }
            }
            else if (data.type === 'playerMoved') {
                if (otherPlayers[data.id]) {
                    otherPlayers[data.id].position.set(data.x, data.y + 1, data.z);
                    otherPlayers[data.id].rotation.y = data.rotationY;
                }
            }
            else if (data.type === 'playerLeft') {
                if (otherPlayers[data.id]) {
                    scene.remove(otherPlayers[data.id]);
                    delete otherPlayers[data.id];
                }
            }
            else if (data.type === 'blockPlaced') {
                console.log('[RECV] blockPlaced:', data);
                if (data.senderId !== myPlayerId) {
                    console.log('[APPLY] Placing block at', data.x, data.y, data.z, 'type:', data.blockType);
                    setBlockType(data.x, data.y, data.z, data.blockType);
                    regenerateChunksAroundBlock(data.x, data.y, data.z);
                } else {
                    console.log('[SKIP] Own block');
                }
            }
            else if (data.type === 'blockBroken') {
                if (data.senderId !== myPlayerId) {
                    setBlockType(data.x, data.y, data.z, null);
                    regenerateChunksAroundBlock(data.x, data.y, data.z);
                }
            }
        }
        
        function addOtherPlayer(id, playerData) {
            // Create player mesh (cyan cube)
            const playerGeo = new THREE.BoxGeometry(0.6, 1.8, 0.6);
            const playerMat = new THREE.MeshLambertMaterial({ color: 0x00FFFF });
            const playerMesh = new THREE.Mesh(playerGeo, playerMat);
            playerMesh.position.set(playerData.x, playerData.y + 1, playerData.z);
            scene.add(playerMesh);
            otherPlayers[id] = playerMesh;
        }
        document.getElementById('win98-content').appendChild(renderer.domElement);

        // Lighting with day/night system
        ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        
        sunLight = new THREE.DirectionalLight(0xffffcc, 0.8);
        sunLight.position.set(50, 100, 50);
        scene.add(sunLight);
        
        moonLight = new THREE.DirectionalLight(0x8888ff, 0.2);
        moonLight.position.set(-50, 50, -50);
        moonLight.visible = false;
        scene.add(moonLight);

        // Texture loader
        const textureLoader = new THREE.TextureLoader();
        const loadedTextures = new Set();
        const failedTextures = new Set();
        
        // Create fallback texture
        function createFallbackTexture(color = '#808080') {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, 16, 16);
            // Add checkerboard pattern to indicate missing texture
            ctx.fillStyle = '#666666';
            for (let x = 0; x < 16; x += 4) {
                for (let y = 0; y < 16; y += 4) {
                    if ((x + y) % 8 === 0) {
                        ctx.fillRect(x, y, 4, 4);
                    }
                }
            }
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }
        
        const fallbackTexture = createFallbackTexture();
        
        // Load actual block textures from textures directory
        function loadTexture(filename) {
            console.log(`Attempting to load: textures/${filename}`);
            const texture = textureLoader.load(`textures/${filename}`, 
                // Success callback
                (tex) => {
                    console.log(`✓ Successfully loaded: textures/${filename}`);
                    loadedTextures.add(filename);
                },
                // Progress callback
                undefined,
                // Error callback
                (err) => {
                    console.error(`✗ Failed to load: textures/${filename}`, err);
                    failedTextures.add(filename);
                    // Replace with fallback
                    texture.image = fallbackTexture.image;
                    texture.needsUpdate = true;
                }
            );
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }
        
        // Create textures that match Minecraft blocks
        function createBlockTexture(color) {
            const canvas = document.createElement('canvas');
            canvas.width = 16;
            canvas.height = 16;
            const ctx = canvas.getContext('2d');
            
            ctx.fillStyle = color;
            ctx.fillRect(0, 0, 16, 16);
            
            // Add pixelated noise for texture
            for (let i = 0; i < 50; i++) {
                const x = Math.floor(Math.random() * 16);
                const y = Math.floor(Math.random() * 16);
                const brightness = Math.random() > 0.5 ? 20 : -20;
                ctx.fillStyle = adjustColor(color, brightness);
                ctx.fillRect(x, y, 1, 1);
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.LinearFilter;
            texture.minFilter = THREE.LinearFilter;
            return texture;
        }
        
        function adjustColor(hex, amount) {
            const num = parseInt(hex.slice(1), 16);
            const r = Math.max(0, Math.min(255, ((num >> 16) & 0xff) + amount));
            const g = Math.max(0, Math.min(255, ((num >> 8) & 0xff) + amount));
            const b = Math.max(0, Math.min(255, (num & 0xff) + amount));
            return '#' + ((r << 16) | (g << 8) | b).toString(16).padStart(6, '0');
        }

        // Block types with textures - 23 blocks!
        const blockTypes = {
            // NATURAL BLOCKS
            grass: { 
                texture: loadTexture('grass_top.png'), 
                sideTexture: loadTexture('grass_side.png'),
                bottomTexture: loadTexture('dirt.png'),
                name: 'Grass' 
            },
            snow_grass: { 
                texture: loadTexture('snow.png'), 
                sideTexture: loadTexture('snow_grass_side.png'),
                bottomTexture: loadTexture('dirt.png'),
                name: 'Snow Grass' 
            },
            mycelium: { 
                texture: loadTexture('mycelium_top.png'), 
                sideTexture: loadTexture('mycelium_side.png'),
                bottomTexture: loadTexture('dirt.png'),
                name: 'Mycelium' 
            },
            dirt: { texture: loadTexture('dirt.png'), name: 'Dirt' },
            farmland: { 
                texture: loadTexture('farmdirt.png'),
                sideTexture: loadTexture('dirt.png'),
                bottomTexture: loadTexture('dirt.png'),
                name: 'Farmland' 
            },
            farmland_wet: { 
                texture: loadTexture('farmdirt_wet.png'),
                sideTexture: loadTexture('dirt.png'),
                bottomTexture: loadTexture('dirt.png'),
                name: 'Wet Farmland' 
            },
            
            // STONE BLOCKS
            stone: { texture: loadTexture('stone.png'), name: 'Stone' },
            cobblestone: { texture: loadTexture('cobblestone.png'), name: 'Cobblestone' },
            deeprock: { texture: loadTexture('deeprock.png'), name: 'Bedrock' },
            gravel: { texture: loadTexture('gravel.png'), name: 'Gravel' },
            stone_bricks: { texture: loadTexture('stone_bricks.png'), name: 'Stone Bricks' },
            chiseled_stone: { texture: loadTexture('chiseld_stone.png'), name: 'Chiseled Stone' },
            mossy_bricks: { texture: loadTexture('mossy_bricks.png'), name: 'Mossy Bricks' },
            cracked_bricks: { texture: loadTexture('cracked_bricks.png'), name: 'Cracked Bricks' },
            end_stone: { texture: loadTexture('end_stone.png'), name: 'End Stone' },
            obsidian: { texture: loadTexture('obsidian.png'), name: 'Obsidian' },
            
            // SAND & SANDSTONE
            sand: { texture: loadTexture('unique_stonesand.png'), name: 'Unique Sand' },
            sandstone: { 
                texture: loadTexture('sand_stone2.png'), 
                sideTexture: loadTexture('sand_stone2.png'),
                bottomTexture: loadTexture('sand_stone2.png'),
                name: 'Sandstone' 
            },
            sand_stone2: { 
                texture: loadTexture('sand_stone2.png'),
                name: 'Smooth Sandstone' 
            },
            
            // WOOD BLOCKS
            oak_log: { 
                texture: loadTexture('oak_wood_top.png'),
                sideTexture: loadTexture('oak_wood_side.png'),
                bottomTexture: loadTexture('oak_wood_top.png'),
                name: 'Oak Log' 
            },
            birch_log: { 
                texture: loadTexture('oak_wood_top.png'),
                sideTexture: loadTexture('birch_side.png'),
                bottomTexture: loadTexture('oak_wood_top.png'),
                name: 'Birch Log' 
            },
            snow_wood: { 
                texture: loadTexture('oak_wood_top.png'),
                sideTexture: loadTexture('snow_wood_side.png'),
                bottomTexture: loadTexture('oak_wood_top.png'),
                name: 'Snow Wood' 
            },
            light_planks: { texture: loadTexture('light_planks.png'), name: 'Light Planks' },
            dark_planks: { texture: loadTexture('dark_planks.png'), name: 'Dark Planks' },
            tropic_planks: { texture: loadTexture('tropic_planks.png'), name: 'Tropic Planks' },
            oak_leaves: { texture: loadTexture('oak_leaves.png'), name: 'Oak Leaves' },
            
            // SLABS & CRAFTING
            slab: { 
                texture: loadTexture('slab_top.png'),
                sideTexture: loadTexture('slab_side.png'),
                bottomTexture: loadTexture('slab_top.png'),
                name: 'Slab' 
            },
            crafting_table: { 
                texture: loadTexture('crafting_table_top.png'),
                sideTexture: loadTexture('crafting_table_side.png'),
                bottomTexture: loadTexture('oak_planks.png'),
                name: 'Crafting Table' 
            },
            
            // BRICKS & CONSTRUCTION
            bricks: { texture: loadTexture('bricks.png'), name: 'Bricks' },
            hell_bricks: { texture: loadTexture('hell_bricks.png'), name: 'Nether Bricks' },
            
            // ORES
            coal_ore: { texture: loadTexture('coal_ore.png'), name: 'Coal Ore' },
            iron_ore: { texture: loadTexture('iron_ore.png'), name: 'Iron Ore' },
            gold_ore: { texture: loadTexture('gold_ore.png'), name: 'Gold Ore' },
            diamond_ore: { texture: loadTexture('diamond_ore.png'), name: 'Diamond Ore' },
            lapis_ore: { texture: loadTexture('lapis_ore.png'), name: 'Lapis Ore' },
            emerald_ore: { texture: loadTexture('emerald_ore.png'), name: 'Emerald Ore' },
            redstone_ore: { texture: loadTexture('redstone_ore.png'), name: 'Redstone Ore' },
            
            // METAL BLOCKS
            iron_block: { texture: loadTexture('iron_block.png'), name: 'Iron Block' },
            gold_block: { texture: loadTexture('gold_block.png'), name: 'Gold Block' },
            diamond_block: { texture: loadTexture('diamond_block.png'), name: 'Diamond Block' },
            lapis_block: { texture: loadTexture('lapis_block.png'), name: 'Lapis Block' },
            emerald_block: { texture: loadTexture('emerald_block.png'), name: 'Emerald Block' },
            
            // GLASS & SPECIAL
            glass: { texture: loadTexture('glass.png'), name: 'Glass' },
            ice: { texture: loadTexture('ice.png'), name: 'Ice' },
            glowstone: { texture: loadTexture('glowstone.png'), name: 'Glowstone' },
            
            // SNOW & ICE
            snow: { texture: loadTexture('snow.png'), name: 'Snow' },
            
            // NETHER BLOCKS
            hellstone: { texture: loadTexture('hellstone.png'), name: 'Netherrack' },
            soulsand: { texture: loadTexture('soulsand.png'), name: 'Soul Sand' },
            
            // WOOL COLORS
            white_wool: { texture: loadTexture('white_cloth.png'), name: 'White Wool' },
            red_wool: { texture: loadTexture('red_wool.png'), name: 'Red Wool' },
            orange_wool: { texture: loadTexture('orange_wool.png'), name: 'Orange Wool' },
            yellow_wool: { texture: loadTexture('yellow_wool.png'), name: 'Yellow Wool' },
            lime_wool: { texture: loadTexture('lime_wool.png'), name: 'Lime Wool' },
            green_wool: { texture: loadTexture('green_cloth.png'), name: 'Green Wool' },
            cyan_wool: { texture: loadTexture('cyan_wool.png'), name: 'Cyan Wool' },
            light_blue_wool: { texture: loadTexture('light_blue_wool.png'), name: 'Light Blue Wool' },
            blue_wool: { texture: loadTexture('blue_wool.png'), name: 'Blue Wool' },
            purple_wool: { texture: loadTexture('purple_wool.png'), name: 'Purple Wool' },
            magenta_wool: { texture: loadTexture('magenta_wool.png'), name: 'Magenta Wool' },
            pink_wool: { texture: loadTexture('pink_wool.png'), name: 'Pink Wool' },
            brown_wool: { texture: loadTexture('brown_wool.png'), name: 'Brown Wool' },
            gray_wool: { texture: loadTexture('gray_wool.png'), name: 'Gray Wool' },
            light_gray_wool: { texture: loadTexture('light_grey_wool.png'), name: 'Light Gray Wool' },
            dark_gray_wool: { texture: loadTexture('dark_gray_wool.png'), name: 'Dark Gray Wool' },
            black_wool: { texture: loadTexture('black_wool.png'), name: 'Black Wool' },
            
            // TNT & EXPLOSIVES
            tnt: { 
                texture: loadTexture('tnt_top.png'), 
                sideTexture: loadTexture('tnt_side.png'),
                bottomTexture: loadTexture('tnt_top.png'),
                name: 'TNT' 
            },
            
            // SPECIAL BLOCKS
            furnace: { 
                texture: loadTexture('furnace_top.png'), 
                sideTexture: loadTexture('furnace_side.png'),
                bottomTexture: loadTexture('furnace_top.png'),
                name: 'Furnace' 
            },
            dispenser: { 
                texture: loadTexture('furnace_top.png'), 
                sideTexture: loadTexture('dispenser_front.png'),
                bottomTexture: loadTexture('furnace_top.png'),
                name: 'Dispenser' 
            },
            note_block: { texture: loadTexture('note_block.png'), name: 'Note Block' },
            jukebox: { 
                texture: loadTexture('jukebox.png'), 
                sideTexture: loadTexture('note_block.png'),
                bottomTexture: loadTexture('note_block.png'),
                name: 'Jukebox' 
            },
            enchant_table: { 
                texture: loadTexture('enchanted_table_top.png'), 
                sideTexture: loadTexture('enchanted_table_side.png'),
                bottomTexture: loadTexture('obsidian.png'),
                name: 'Enchant Table' 
            },
            end_portal: { 
                texture: loadTexture('end_portal_top.png'), 
                sideTexture: loadTexture('end_portal_side.png'),
                bottomTexture: loadTexture('end_stone.png'),
                name: 'End Portal' 
            },
            dragon_egg: { texture: loadTexture('dragon_egg.png'), name: 'Dragon Egg' },
            mob_spawner: { texture: loadTexture('mob_spawner.png'), name: 'Mob Spawner' },
            
            // FOOD & PLANTS
            pumpkin: { 
                texture: loadTexture('pumpkin_top.png'), 
                sideTexture: loadTexture('pumpkin_side.png'),
                bottomTexture: loadTexture('pumpkin_top.png'),
                name: 'Pumpkin' 
            },
            melon: { 
                texture: loadTexture('melon_top.png'), 
                sideTexture: loadTexture('melon_side.png'),
                bottomTexture: loadTexture('melon_top.png'),
                name: 'Melon' 
            },
            cake: { 
                texture: loadTexture('cake_top.png'), 
                sideTexture: loadTexture('cake_side.png'),
                bottomTexture: loadTexture('cake_bottom.png'),
                name: 'Cake' 
            },
            cactus: { 
                texture: loadTexture('cactus_top.png'), 
                sideTexture: loadTexture('cactus_side.png'),
                bottomTexture: loadTexture('cactus_bottom.png'),
                name: 'Cactus' 
            },
            mushroom_block: { texture: loadTexture('mushroom_block.png'), name: 'Mushroom Block' },
            sponge: { texture: loadTexture('sponge.png'), name: 'Sponge' },
            clay: { texture: loadTexture('clay.png'), name: 'Clay' },
            
            // FLOWERS & DECORATIONS
            red_flower: { texture: loadTexture('red_flower.png'), name: 'Red Flower' },
            yellow_flower: { texture: loadTexture('yello_flower.png'), name: 'Yellow Flower' },
            red_mushroom: { texture: loadTexture('red_flower.png'), name: 'Red Mushroom' },
            brown_mushroom: { texture: loadTexture('mushroom_brown.png'), name: 'Brown Mushroom' },
            bush: { texture: loadTexture('oak_leaves.png'), name: 'Bush' },
            sugar_cane: { texture: loadTexture('sugar_cane.png'), name: 'Sugar Cane' },
            
            // SAPLINGS
            oak_sapling: { texture: loadTexture('oak_sapling.png'), name: 'Oak Sapling' },
            birch_sapling: { texture: loadTexture('birch_sapling.png'), name: 'Birch Sapling' },
            snow_sapling: { texture: loadTexture('snow_tree_sapling.png'), name: 'Snow Sapling' },
            
            // MISC
            water: { texture: loadTexture('water.png'), name: 'Water' },
            cobweb: { texture: loadTexture('cobwebwww.png'), name: 'Cobweb' },
            iron_bars: { texture: loadTexture('iron_bars.png'), name: 'Iron Bars' },
            ladder: { texture: loadTexture('ladder.png'), name: 'Ladder' },
            trapdoor: { texture: loadTexture('trapdoor.png'), name: 'Trapdoor' }
        };

        // Create inventory array
        const allBlocks = Object.keys(blockTypes);
        let selectedBlockIndex = 0;
        let selectedBlock = allBlocks[0];
        let hotbarSlots = [];

        // Initialize hotbar with first 9 blocks
        function initHotbar() {
            const hotbarContainer = document.getElementById('hotbar');
            for (let i = 0; i < 9; i++) {
                const slot = document.createElement('div');
                slot.className = 'hotbar-slot';
                if (i === 0) slot.classList.add('active');
                slot.innerHTML = `<span class="slot-number">${i + 1}</span><span>${blockTypes[allBlocks[i]].name.substring(0, 8)}</span>`;
                slot.onclick = () => selectSlot(i);
                hotbarContainer.appendChild(slot);
                hotbarSlots.push(i);
            }
            populateInventory();
            
            // Report texture loading status after a short delay
            setTimeout(() => {
                console.log(`\n=== Texture Loading Report ===`);
                console.log(`✓ Successfully loaded: ${loadedTextures.size} textures`);
                console.log(`✗ Failed to load: ${failedTextures.size} textures`);
                if (failedTextures.size > 0) {
                    console.log(`Failed textures:`, Array.from(failedTextures));
                }
                console.log(`=============================\n`);
            }, 2000);
        }

        function populateInventory() {
            const inventoryGrid = document.getElementById('inventoryGrid');
            inventoryGrid.innerHTML = '';
            
            allBlocks.forEach((blockKey, index) => {
                const block = blockTypes[blockKey];
                const item = document.createElement('div');
                item.className = 'inventory-item';
                if (index === selectedBlockIndex) item.classList.add('selected');
                
                // Create mini canvas for texture preview
                const canvas = document.createElement('canvas');
                canvas.width = 48;
                canvas.height = 48;
                const ctx = canvas.getContext('2d');
                ctx.imageSmoothingEnabled = false;
                
                // Draw texture with pixelated rendering
                if (block.texture && block.texture.image && block.texture.image.complete) {
                    // Draw texture filling the entire canvas
                    ctx.drawImage(block.texture.image, 0, 0, 48, 48);
                } else {
                    // Placeholder while texture loads
                    ctx.fillStyle = '#8B8B8B';
                    ctx.fillRect(0, 0, 48, 48);
                    ctx.fillStyle = '#666';
                    ctx.fillRect(2, 2, 44, 44);
                }
                
                // Create tooltip
                const tooltip = document.createElement('div');
                tooltip.className = 'inventory-tooltip';
                tooltip.textContent = block.name;
                
                item.appendChild(canvas);
                item.appendChild(tooltip);
                item.onclick = () => selectBlockFromInventory(index);
                inventoryGrid.appendChild(item);
            });
        }

        function selectBlockFromInventory(index) {
            selectedBlockIndex = index;
            selectedBlock = allBlocks[selectedBlockIndex];
            updateInfo();
            populateInventory();
            
            // Update hotbar to center on selected block
            hotbarSlots = [];
            for (let i = 0; i < 9; i++) {
                let idx = (selectedBlockIndex - 4 + i + allBlocks.length) % allBlocks.length;
                hotbarSlots.push(idx);
            }
            
            const slots = document.querySelectorAll('.hotbar-slot');
            slots.forEach((slot, i) => {
                const blockIdx = hotbarSlots[i];
                const blockName = blockTypes[allBlocks[blockIdx]].name;
                slot.innerHTML = `<span class="slot-number">${i + 1}</span><span>${blockName.substring(0, 8)}</span>`;
                slot.classList.toggle('active', i === 4);
            });
        }

        function toggleInventory() {
            inventoryOpen = !inventoryOpen;
            const menu = document.getElementById('inventoryMenu');
            menu.style.display = inventoryOpen ? 'block' : 'none';
            if (inventoryOpen) {
                populateInventory();
                document.exitPointerLock();
            }
        }

        function selectSlot(index) {
            document.querySelectorAll('.hotbar-slot').forEach((slot, i) => {
                slot.classList.toggle('active', i === index);
            });
            selectedBlockIndex = hotbarSlots[index];
            selectedBlock = allBlocks[selectedBlockIndex];
            updateInfo();
        }

        function scrollBlocks(direction) {
            // Scroll through all blocks and update hotbar
            selectedBlockIndex += direction;
            if (selectedBlockIndex < 0) selectedBlockIndex = allBlocks.length - 1;
            if (selectedBlockIndex >= allBlocks.length) selectedBlockIndex = 0;
            selectedBlock = allBlocks[selectedBlockIndex];
            
            // Update hotbar slots
            hotbarSlots = [];
            for (let i = 0; i < 9; i++) {
                let idx = (selectedBlockIndex - 4 + i + allBlocks.length) % allBlocks.length;
                hotbarSlots.push(idx);
            }
            
            // Update hotbar UI
            const slots = document.querySelectorAll('.hotbar-slot');
            slots.forEach((slot, i) => {
                const blockIdx = hotbarSlots[i];
                const blockName = blockTypes[allBlocks[blockIdx]].name;
                slot.innerHTML = `<span class="slot-number">${i + 1}</span><span>${blockName.substring(0, 8)}</span>`;
                slot.classList.toggle('active', i === 4); // Center slot is active
            });
            
            updateInfo();
        }

        // Keyboard state
        const keys = {};
        document.addEventListener('keydown', (e) => {
            keys[e.code] = true;
            
            // Settings menu
            if (e.code === 'Escape') {
                e.preventDefault();
                if (inventoryOpen) {
                    toggleInventory();
                } else {
                    toggleSettings();
                }
            }
            
            // Crafting menu
            if (e.code === 'KeyC' && !settingsOpen) {
                toggleCrafting();
            }
            
            // Inventory menu
            if (e.code === 'KeyI' && !settingsOpen) {
                toggleInventory();
            }
            
            // Toggle camera view (F5)
            if (e.code === 'F5') {
                e.preventDefault();
                thirdPerson = !thirdPerson;
                if (playerMesh) {
                    playerMesh.visible = thirdPerson;
                    console.log('Third-person mode:', thirdPerson, 'Player mesh visible:', playerMesh.visible);
                }
            }
            
            // Hotbar selection
            if (e.code === 'Digit1') selectSlot(0);
            if (e.code === 'Digit2') selectSlot(1);
            if (e.code === 'Digit3') selectSlot(2);
            if (e.code === 'Digit4') selectSlot(3);
            if (e.code === 'Digit5') selectSlot(4);
            if (e.code === 'Digit6') selectSlot(5);
            if (e.code === 'Digit7') selectSlot(6);
            if (e.code === 'Digit8') selectSlot(7);
            if (e.code === 'Digit9') selectSlot(8);
            // Arrow keys to scroll blocks
            if (e.code === 'ArrowRight') scrollBlocks(1);
            if (e.code === 'ArrowLeft') scrollBlocks(-1);
        });
        document.addEventListener('keyup', (e) => keys[e.code] = false);

        // Mouse wheel to scroll blocks
        document.addEventListener('wheel', (e) => {
            if (isLocked) {
                e.preventDefault();
                scrollBlocks(e.deltaY > 0 ? 1 : -1);
            }
        });

        initHotbar();

        function updateInfo() {
            document.getElementById('info').innerHTML = `
                <h3>⛏️ Minecraft Nesa Explorer 5 ⛏️</h3>
                <p><strong>Click to start</strong><br>
                WASD: Move<br>
                Mouse: Look<br>
                Space: Fly Up<br>
                Shift: Fly Down<br>
                I: Inventory<br>
                1-9: Hotbar slots<br>
                Mouse Wheel / ←→: Scroll blocks<br>
                Left Click: Break<br>
                Right Click: Place<br>
                <strong style="color: #FFD700;">Block: ${blockTypes[selectedBlock].name} (${selectedBlockIndex + 1}/${allBlocks.length})</strong><br>
                <em>World: 1024x1024 Beta Terrain</em></p>
            `;
        }
        updateInfo();

        // Mouse controls
        let pitch = 0, yaw = 0;
        let isLocked = false;
        let justLocked = false;

        // Add browser prefixes for pointer lock support
        renderer.domElement.requestPointerLock = renderer.domElement.requestPointerLock ||
                                                  renderer.domElement.mozRequestPointerLock ||
                                                  renderer.domElement.webkitRequestPointerLock;

        document.exitPointerLock = document.exitPointerLock ||
                                   document.mozExitPointerLock ||
                                   document.webkitExitPointerLock;

        renderer.domElement.addEventListener('click', (e) => {
            if (!isLocked) {
                e.preventDefault();
                e.stopPropagation();
                renderer.domElement.requestPointerLock();
                justLocked = true;
                setTimeout(() => justLocked = false, 500);
            }
        });

        // Listen to all browser-prefixed pointer lock events
        document.addEventListener('pointerlockchange', onPointerLockChange);
        document.addEventListener('mozpointerlockchange', onPointerLockChange);
        document.addEventListener('webkitpointerlockchange', onPointerLockChange);

        function onPointerLockChange() {
            isLocked = document.pointerLockElement === renderer.domElement ||
                       document.mozPointerLockElement === renderer.domElement ||
                       document.webkitPointerLockElement === renderer.domElement;
        }

        document.addEventListener('mousemove', (e) => {
            if (!isLocked) return;
            yaw -= e.movementX * 0.002;
            pitch -= e.movementY * 0.002;
            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
        });

        // Raycaster for block placement/breaking
        const raycaster = new THREE.Raycaster();
        raycaster.far = 8;

        // Block highlight cursor
        const highlightGeometry = new THREE.BoxGeometry(1.01, 1.01, 1.01);
        const highlightMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffffff, 
            wireframe: true,
            transparent: true,
            opacity: 0.5,
            linewidth: 2
        });
        const highlightMesh = new THREE.Mesh(highlightGeometry, highlightMaterial);
        highlightMesh.visible = false;
        scene.add(highlightMesh);

        let targetBlock = null; // Store targeted block info

        document.addEventListener('mousedown', (e) => {
            if (!isLocked || justLocked || !targetBlock) return;
            
            if (e.button === 0) {
                // Left click - break block
                const { x, y, z } = targetBlock;
                const key = `${x},${y},${z}`;
                world[key] = null;
                regenerateChunk(x, z);
                
                // Create break particles
                const blockType = targetBlock.type;
                const blockColors = {
                    'grass': 0x7CFC00, 'dirt': 0x8B4513, 'stone': 0x808080,
                    'coal_ore': 0x333333, 'iron_ore': 0xC77B00, 
                    'gold_ore': 0xFFD700, 'diamond_ore': 0x00FFFF
                };
                const color = blockColors[blockType] || 0x8B4513;
                for (let i = 0; i < 8; i++) {
                    createParticle(
                        x + Math.random(),
                        y + Math.random(), 
                        z + Math.random(),
                        color
                    );
                }
                
                // Broadcast block break to multiplayer
                if (socket) {
                    const msg = {
                        type: 'blockBroken',
                        x: x,
                        y: y,
                        z: z,
                        senderId: myPlayerId
                    };
                    console.log('[SEND] blockBroken:', msg);
                    sendMultiplayer(msg);
                }
                
            } else if (e.button === 2) {
                // Right click - place block
                const { placeX, placeY, placeZ } = targetBlock;
                const key = `${placeX},${placeY},${placeZ}`;
                
                // Check if position is empty and not inside player
                const playerBox = {
                    minX: Math.floor(camera.position.x) - 1,
                    maxX: Math.floor(camera.position.x) + 1,
                    minY: Math.floor(camera.position.y - 1.5),
                    maxY: Math.floor(camera.position.y + 0.5),
                    minZ: Math.floor(camera.position.z) - 1,
                    maxZ: Math.floor(camera.position.z) + 1
                };
                
                const wouldCollide = placeX >= playerBox.minX && placeX <= playerBox.maxX &&
                                   placeY >= playerBox.minY && placeY <= playerBox.maxY &&
                                   placeZ >= playerBox.minZ && placeZ <= playerBox.maxZ;
                
                if (!getBlockType(placeX, placeY, placeZ) && !wouldCollide) {
                    world[key] = selectedBlock;
                    regenerateChunk(placeX, placeZ);
                    
                    // Broadcast to multiplayer
                    if (socket) {
                        const msg = {
                            type: 'blockPlaced',
                            x: placeX,
                            y: placeY,
                            z: placeZ,
                            blockType: selectedBlock,
                            senderId: myPlayerId
                        };
                        console.log('[SEND] blockPlaced:', msg);
                        sendMultiplayer(msg);
                    }
                }
            }
        });

        document.addEventListener('contextmenu', (e) => e.preventDefault());

        // Perlin noise for beta-like terrain
        const blockSize = 1;
        const worldSize = 512; // 1024x1024 world (-512 to 512)
        const waterLevel = 32;
        const maxHeight = 96; // Tall mountains!

        function hash(x, z, seed = null) {
            if (seed === null) seed = worldSeed; // Use shared world seed
            let h = seed + x * 374761393 + z * 668265263;
            h = (h ^ (h >> 13)) * 1274126177;
            return (h ^ (h >> 16)) / 2147483648.0;
        }

        function noise2D(x, z) {
            const x0 = Math.floor(x), z0 = Math.floor(z);
            const x1 = x0 + 1, z1 = z0 + 1;
            const fx = x - x0, fz = z - z0;
            const sx = fx * fx * (3 - 2 * fx);
            const sz = fz * fz * (3 - 2 * fz);
            
            const n00 = hash(x0, z0);
            const n10 = hash(x1, z0);
            const n01 = hash(x0, z1);
            const n11 = hash(x1, z1);
            
            const nx0 = n00 + sx * (n10 - n00);
            const nx1 = n01 + sx * (n11 - n01);
            return nx0 + sz * (nx1 - nx0);
        }

        function fractalNoise(x, z, octaves) {
            let total = 0;
            let amplitude = 1;
            let maxValue = 0;
            for (let i = 0; i < octaves; i++) {
                total += noise2D(x * (0.01 * Math.pow(2, i)), z * (0.01 * Math.pow(2, i))) * amplitude;
                maxValue += amplitude;
                amplitude *= 0.5;
            }
            return total / maxValue;
        }

        const world = {};
        const chunks = {}; // Store chunk meshes
        const caveCache = {}; // Cache cave calculations
        const CHUNK_SIZE = 16;
        const RENDER_DISTANCE = 1; // chunks (1 * 16 = 16 blocks)

        // Get chunk key
        function getChunkKey(x, z) {
            const cx = Math.floor(x / CHUNK_SIZE);
            const cz = Math.floor(z / CHUNK_SIZE);
            return `${cx},${cz}`;
        }

        // Generate heightmap data (no meshes yet)
        const heightMap = {};
        const treePositions = {};
        const lakePositions = {}; // Water lakes
        const flowerPositions = {}; // Flower decorations
        const buildings = [];
        
        function generateHeightMap() {
            let treeCount = 0;
            let lakeCount = 0;
            let flowerCount = 0;
            
            console.log(`Generating ${selectedWorldType} world...`);
            
            let processed = 0;
            const totalBlocks = (worldSize * 2 + 1) * (worldSize * 2 + 1);
            
            for (let x = -worldSize; x <= worldSize; x++) {
                for (let z = -worldSize; z <= worldSize; z++) {
                    processed++;
                    let height;
                    
                    if (selectedWorldType === 'flat') {
                        // Flat world at y=32
                        height = waterLevel;
                    } else if (selectedWorldType === 'extreme') {
                        // Extreme mountains - VERY tall
                        const continentalness = fractalNoise(x * 0.3, z * 0.3, 3) * 0.5 + 0.5;
                        const peaksValleys = fractalNoise(x * 1.5, z * 1.5, 5);
                        const mountainHeight = Math.pow(continentalness, 1.2) * 200;
                        const peakDetail = peaksValleys * 40;
                        height = Math.floor(waterLevel + mountainHeight + peakDetail);
                        height = Math.min(height, 250); // Cap at 250 for extreme
                    } else {
                        // Normal, snowy, desert - rolling hills with biomes
                        const biomeNoise = fractalNoise(x * 0.005, z * 0.005, 2);
                        const continentalness = fractalNoise(x * 0.5, z * 0.5, 2) * 0.5 + 0.5;
                        const erosion = fractalNoise(x, z, 3) * 0.5 + 0.5;
                        const peaksValleys = fractalNoise(x * 2, z * 2, 4);
                        
                        if (continentalness > 0.6) {
                            // Mountains biome
                            const hillHeight = (continentalness - 0.6) * 50;
                            const hillDetail = peaksValleys * 10;
                            height = Math.floor(waterLevel + 8 + hillHeight + hillDetail);
                        } else if (biomeNoise > 0.3) {
                            // Hills biome
                            const hillHeight = biomeNoise * 30;
                            height = Math.floor(waterLevel + 5 + hillHeight + peaksValleys * 8);
                        } else if (biomeNoise < -0.2) {
                            // River/valley biome
                            height = Math.floor(waterLevel - 2 + Math.abs(biomeNoise) * 5);
                        } else {
                            // Plains biome
                            const plainHeight = fractalNoise(x * 0.8, z * 0.8, 2) * 6;
                            height = Math.floor(waterLevel + 2 + plainHeight);
                        }
                        
                        // Trees for normal world only
                        if (selectedWorldType === 'normal' && height > waterLevel && Math.random() < 0.02) {
                            treePositions[`${x},${z}`] = true;
                            treeCount++;
                        }
                        
                        // Flowers for normal world
                        if (selectedWorldType === 'normal' && height > waterLevel && Math.random() < 0.03) {
                            flowerPositions[`${x},${z}`] = Math.random() < 0.5 ? 'red_flower' : 'yellow_flower';
                            flowerCount++;
                        }
                    }
                    
                    height = Math.max(0, Math.min(maxHeight, height));
                    heightMap[`${x},${z}`] = height;
                    
                    // Update progress every 5%
                    if (processed % Math.floor(totalBlocks / 20) === 0) {
                        const progress = Math.floor((processed / totalBlocks) * 100);
                        document.getElementById('loadingPercent').innerText = progress + '%';
                        document.getElementById('progressBar').style.width = progress + '%';
                        document.getElementById('loadingText').innerText = `Generating ${selectedWorldType} world... (${progress}%)`;
                    }
                }
            }
            console.log(`Generated ${treeCount} trees, ${flowerCount} flowers`);
        }

        // Get terrain height at position
        function getTerrainHeight(x, z) {
            const key = `${Math.floor(x)},${Math.floor(z)}`;
            return heightMap[key] || waterLevel;
        }
        
        // Get block type at position
        function getBlockType(x, y, z) {
            // Check if manually placed/removed first
            const blockKey = `${x},${y},${z}`;
            if (world.hasOwnProperty(blockKey)) {
                return world[blockKey]; // Returns the block type or null if removed
            }
            
            const key = `${x},${z}`;
            const height = heightMap[key];
            
            // Check for water lakes
            if (lakePositions[key] && y <= height && y >= height - 2 && height > waterLevel) {
                if (y === height) return null; // Air above water
                return 'water'; // Water in lake
            }
            
            if (height === undefined || y > height) return null;
            
            // Spawn platform (5x5 cobblestone with ice border)
            const spawnX = 0, spawnZ = 0;
            if (x >= spawnX - 2 && x <= spawnX + 2 && z >= spawnZ - 2 && z <= spawnZ + 2 && y === waterLevel) {
                // Ice border, cobblestone center
                if (x === spawnX - 2 || x === spawnX + 2 || z === spawnZ - 2 || z === spawnZ + 2) {
                    return 'ice';
                } else {
                    return 'cobblestone';
                }
            }
            
            // Generate block type based on height and world type
            if (y === 0) {
                return 'bedrock'; // Bedrock layer
            } else if (y === height && height > waterLevel) {
                // Surface block depends on world type
                if (selectedWorldType === 'snowy') {
                    return 'snow_grass';
                } else if (selectedWorldType === 'desert') {
                    return 'sand';
                } else {
                    return 'grass'; // Normal/Extreme/Flat
                }
            } else if (y > height - 4 && height > waterLevel) {
                // Sub-surface
                if (selectedWorldType === 'desert') {
                    return 'sand';
                } else {
                    return 'dirt';
                }
            } else if (y > height - 2 && height <= waterLevel) {
                // Less dirt underwater (or sand in desert)
                if (selectedWorldType === 'desert') {
                    return 'sand';
                } else {
                    return 'dirt';
                }
            } else {
                // Underground - check for caves first (with caching)
                const caveKey = `${x},${y},${z}`;
                let isCave = caveCache[caveKey];
                
                if (isCave === undefined) {
                    const caveNoise1 = fractalNoise(x * 0.05, z * 0.05, 3) + fractalNoise(y * 0.1, x * 0.05, 2);
                    const caveNoise2 = fractalNoise(z * 0.05, y * 0.1, 3) + fractalNoise(x * 0.05, z * 0.05, 2);
                    const caveThreshold = 0.6;
                    isCave = y > 5 && y < height - 5 && Math.abs(caveNoise1) < caveThreshold && Math.abs(caveNoise2) < caveThreshold;
                    caveCache[caveKey] = isCave;
                }
                
                // Create caves
                if (isCave) {
                    return null; // Cave air
                }
                
                // Underground - stone with ores
                const oreRand = Math.random();
                const depth = height - y;
                
                // Biome-based ore distribution
                const biomeType = Math.abs(fractalNoise(x * 0.01, z * 0.01, 2));
                
                if (y < 5) {
                    return 'bedrock'; // Bedrock layer at bottom
                }
                else if (depth > 40 && oreRand < 0.002) {
                    return 'diamond_ore'; // Very rare, deep
                }
                else if (depth > 25 && oreRand < 0.008) {
                    return 'gold_ore'; // Rare, medium-deep
                }
                else if (depth > 20 && oreRand < 0.01 && biomeType > 0.5) {
                    return 'lapis_ore'; // Lapis in specific biomes
                }
                else if (depth > 15 && oreRand < 0.02) {
                    return 'iron_ore'; // Uncommon, medium depth
                }
                else if (depth > 10 && oreRand < 0.015 && biomeType < 0.3) {
                    return 'redstone_ore'; // Redstone in specific areas
                }
                else if (depth > 5 && oreRand < 0.05) {
                    return 'coal_ore'; // Common, any depth
                }
                else if (oreRand < 0.03) {
                    return 'gravel'; // Random gravel pockets
                }
                
                return 'stone'; // Default stone
            }
        }

        // Set block type in world (for multiplayer sync)
        function setBlockType(x, y, z, blockType) {
            const blockKey = `${x},${y},${z}`;
            if (blockType === null) {
                world[blockKey] = null; // Mark as removed
            } else {
                world[blockKey] = blockType; // Set block type
            }
        }

        // Generate chunk mesh with merged geometry
        function generateChunk(chunkX, chunkZ) {
            const chunkKey = `${chunkX},${chunkZ}`;
            if (chunks[chunkKey]) return; // Already generated
            
            const geometries = {};
            
            // Collect all blocks in chunk
            for (let localX = 0; localX < CHUNK_SIZE; localX++) {
                for (let localZ = 0; localZ < CHUNK_SIZE; localZ++) {
                    const x = chunkX * CHUNK_SIZE + localX;
                    const z = chunkZ * CHUNK_SIZE + localZ;
                    
                    if (x < -worldSize || x > worldSize || z < -worldSize || z > worldSize) continue;
                    
                    const heightKey = `${x},${z}`;
                    const height = heightMap[heightKey] || 0;
                    
                    for (let y = 0; y <= Math.max(height, maxHeight); y++) {
                        const blockType = getBlockType(x, y, z);
                        if (!blockType) continue;
                        
                        // Check if block is exposed (has at least one visible face)
                        const isExposed = 
                            !getBlockType(x + 1, y, z) ||
                            !getBlockType(x - 1, y, z) ||
                            !getBlockType(x, y + 1, z) ||
                            !getBlockType(x, y - 1, z) ||
                            !getBlockType(x, y, z + 1) ||
                            !getBlockType(x, y, z - 1);
                        
                        if (isExposed) {
                            // Apply face culling to all blocks for better performance
                            const specialKey = blockType + '_culled';
                            if (!geometries[specialKey]) geometries[specialKey] = [];
                            
                            // Check each face individually
                            const faces = [];
                            
                            // Right face (+X)
                            if (!getBlockType(x + 1, y, z)) {
                                faces.push({ dir: 'right', normal: [1, 0, 0] });
                            }
                            // Left face (-X)
                            if (!getBlockType(x - 1, y, z)) {
                                faces.push({ dir: 'left', normal: [-1, 0, 0] });
                            }
                            // Top face (+Y)
                            if (!getBlockType(x, y + 1, z)) {
                                faces.push({ dir: 'top', normal: [0, 1, 0] });
                            }
                            // Bottom face (-Y)
                            if (!getBlockType(x, y - 1, z)) {
                                faces.push({ dir: 'bottom', normal: [0, -1, 0] });
                            }
                            // Front face (+Z)
                            if (!getBlockType(x, y, z + 1)) {
                                faces.push({ dir: 'front', normal: [0, 0, 1] });
                            }
                            // Back face (-Z)
                            if (!getBlockType(x, y, z - 1)) {
                                faces.push({ dir: 'back', normal: [0, 0, -1] });
                            }
                            
                            // Create geometry for each visible face
                            faces.forEach(face => {
                                const geo = new THREE.PlaneGeometry(1, 1);
                                
                                // Position and rotate plane based on face direction
                                if (face.dir === 'right') {
                                    geo.rotateY(Math.PI / 2);
                                    geo.translate(x + 0.5, y, z);
                                } else if (face.dir === 'left') {
                                    geo.rotateY(-Math.PI / 2);
                                    geo.translate(x - 0.5, y, z);
                                } else if (face.dir === 'top') {
                                    geo.rotateX(-Math.PI / 2);
                                    geo.translate(x, y + 0.5, z);
                                } else if (face.dir === 'bottom') {
                                    geo.rotateX(Math.PI / 2);
                                    geo.translate(x, y - 0.5, z);
                                } else if (face.dir === 'front') {
                                    geo.translate(x, y, z + 0.5);
                                } else if (face.dir === 'back') {
                                    geo.rotateY(Math.PI);
                                    geo.translate(x, y, z - 0.5);
                                }
                                
                                // Determine texture based on face and block type
                                let texture;
                                // Check if block has directional textures
                                if (blockTypes[blockType] && (blockTypes[blockType].sideTexture || blockTypes[blockType].bottomTexture)) {
                                    // Multi-texture blocks (grass, logs, TNT, furnace, etc.)
                                    if (face.dir === 'top') {
                                        texture = blockTypes[blockType].texture;
                                    } else if (face.dir === 'bottom') {
                                        texture = blockTypes[blockType].bottomTexture || blockTypes[blockType].texture;
                                    } else {
                                        texture = blockTypes[blockType].sideTexture || blockTypes[blockType].texture;
                                    }
                                } else {
                                    // Single texture blocks
                                    texture = blockTypes[blockType] ? blockTypes[blockType].texture : null;
                                }
                                
                                // Only apply transparency to blocks that need it
                                const needsTransparency = blockType === 'oak_leaves' || blockType === 'red_flower' || blockType === 'yellow_flower';
                                const mat = new THREE.MeshLambertMaterial({ 
                                    map: texture,
                                    alphaTest: needsTransparency ? 0.9 : 0,
                                    transparent: needsTransparency
                                });
                                const mesh = new THREE.Mesh(geo, mat);
                                geometries[specialKey].push(mesh);
                            });
                        }
                    }
                    
                    // Water
                    if (height < waterLevel && !world[`${x},${waterLevel},${z}`]) {
                        if (!geometries['water']) geometries['water'] = [];
                        const geo = new THREE.BoxGeometry(1, 1, 1);
                        geo.translate(x, waterLevel, z);
                        geometries['water'].push(geo);
                    }
                    
                    // Flowers on grass
                    const flowerKey = `${x},${z}`;
                    if (flowerPositions[flowerKey] && height > waterLevel) {
                        const flowerType = flowerPositions[flowerKey];
                        const flowerY = height + 1;
                        
                        if (!getBlockType(x, flowerY, z)) {
                            if (!geometries[flowerType]) geometries[flowerType] = [];
                            const geo = new THREE.BoxGeometry(0.3, 0.6, 0.3);
                            geo.translate(x, flowerY, z);
                            geometries[flowerType].push(geo);
                        }
                    }
                }
            }
            
            // Generate trees in this chunk
            for (const treeKey in treePositions) {
                const [tx, tz] = treeKey.split(',').map(Number);
                
                // Check if tree is in this chunk
                if (tx >= chunkX * CHUNK_SIZE && tx < (chunkX + 1) * CHUNK_SIZE &&
                    tz >= chunkZ * CHUNK_SIZE && tz < (chunkZ + 1) * CHUNK_SIZE) {
                    
                    const treeGroundHeight = heightMap[`${tx},${tz}`] || 0;
                    
                    if (treeGroundHeight > waterLevel && treeGroundHeight < maxHeight - 10) {
                        const treeHeight = 6 + Math.floor(Math.random() * 3);
                        const trunkTop = treeGroundHeight + treeHeight;
                        
                        // Tree trunk - using proper directional textures
                        for (let ty = treeGroundHeight + 1; ty <= trunkTop; ty++) {
                            // Create trunk with proper top/side/bottom textures
                            const faces = [
                                { dir: 'right', normal: [1, 0, 0] },
                                { dir: 'left', normal: [-1, 0, 0] },
                                { dir: 'top', normal: [0, 1, 0] },
                                { dir: 'bottom', normal: [0, -1, 0] },
                                { dir: 'front', normal: [0, 0, 1] },
                                { dir: 'back', normal: [0, 0, -1] }
                            ];
                            
                            faces.forEach(face => {
                                const geo = new THREE.PlaneGeometry(1, 1);
                                
                                if (face.dir === 'right') {
                                    geo.rotateY(Math.PI / 2);
                                    geo.translate(tx + 0.5, ty, tz);
                                } else if (face.dir === 'left') {
                                    geo.rotateY(-Math.PI / 2);
                                    geo.translate(tx - 0.5, ty, tz);
                                } else if (face.dir === 'top') {
                                    geo.rotateX(-Math.PI / 2);
                                    geo.translate(tx, ty + 0.5, tz);
                                } else if (face.dir === 'bottom') {
                                    geo.rotateX(Math.PI / 2);
                                    geo.translate(tx, ty - 0.5, tz);
                                } else if (face.dir === 'front') {
                                    geo.translate(tx, ty, tz + 0.5);
                                } else if (face.dir === 'back') {
                                    geo.rotateY(Math.PI);
                                    geo.translate(tx, ty, tz - 0.5);
                                }
                                
                                // Determine texture based on face
                                let texture;
                                if (face.dir === 'top' || face.dir === 'bottom') {
                                    texture = blockTypes['oak_log'].texture;
                                } else {
                                    texture = blockTypes['oak_log'].sideTexture || blockTypes['oak_log'].texture;
                                }
                                
                                const mat = new THREE.MeshLambertMaterial({ 
                                    map: texture
                                });
                                const mesh = new THREE.Mesh(geo, mat);
                                
                                if (!geometries['oak_log_faces']) geometries['oak_log_faces'] = [];
                                geometries['oak_log_faces'].push(mesh);
                            });
                        }
                        
                        // Leaves - simple boxes with leaf texture
                        for (let lx = -2; lx <= 2; lx++) {
                            for (let lz = -2; lz <= 2; lz++) {
                                for (let ly = -1; ly <= 2; ly++) {
                                    const leafY = trunkTop + ly;
                                    if (leafY <= maxHeight && !(lx === 0 && lz === 0 && ly < 0)) {
                                        if (!geometries['oak_leaves']) geometries['oak_leaves'] = [];
                                        const geo = new THREE.BoxGeometry(1, 1, 1);
                                        geo.translate(tx + lx, leafY, tz + lz);
                                        geometries['oak_leaves'].push(geo);
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Generate buildings in this chunk
            for (const building of buildings) {
                const bx = building.x;
                const bz = building.z;
                const bw = building.width;
                const bl = building.length;
                const bh = building.height;
                
                // Check if building overlaps this chunk
                if (bx - bw/2 < (chunkX + 1) * CHUNK_SIZE && bx + bw/2 >= chunkX * CHUNK_SIZE &&
                    bz - bl/2 < (chunkZ + 1) * CHUNK_SIZE && bz + bl/2 >= chunkZ * CHUNK_SIZE) {
                    
                    const buildingGroundHeight = heightMap[`${bx},${bz}`] || waterLevel + 1;
                    
                    if (buildingGroundHeight > waterLevel) {
                        for (let bxx = Math.floor(bx - bw/2); bxx <= Math.floor(bx + bw/2); bxx++) {
                            for (let bzz = Math.floor(bz - bl/2); bzz <= Math.floor(bz + bl/2); bzz++) {
                                // Check if block is in current chunk
                                if (bxx >= chunkX * CHUNK_SIZE && bxx < (chunkX + 1) * CHUNK_SIZE &&
                                    bzz >= chunkZ * CHUNK_SIZE && bzz < (chunkZ + 1) * CHUNK_SIZE) {
                                    
                                    const isWall = bxx === Math.floor(bx - bw/2) || bxx === Math.floor(bx + bw/2) ||
                                                   bzz === Math.floor(bz - bl/2) || bzz === Math.floor(bz + bl/2);
                                    
                                    for (let byy = buildingGroundHeight + 1; byy <= buildingGroundHeight + bh; byy++) {
                                        const isRoof = byy === buildingGroundHeight + bh;
                                        
                                        if (isWall || isRoof) {
                                            let blockType = 'light_planks';
                                            if (building.type === 'tower') blockType = 'stone';
                                            if (isRoof) blockType = 'light_planks';
                                            
                                            if (!geometries[blockType]) geometries[blockType] = [];
                                            const geo = new THREE.BoxGeometry(1, 1, 1);
                                            geo.translate(bxx, byy, bzz);
                                            geometries[blockType].push(geo);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            
            // Merge geometries per block type
            const chunkGroup = new THREE.Group();
            for (const blockType in geometries) {
                if (geometries[blockType].length === 0) continue;
                
                // All blocks now use face culling (ending with _culled)
                if (blockType.endsWith('_culled')) {
                    geometries[blockType].forEach(mesh => chunkGroup.add(mesh));
                } else if (blockType === 'oak_log_faces') {
                    // Tree trunks with proper directional textures (already meshed)
                    geometries[blockType].forEach(mesh => chunkGroup.add(mesh));
                } else {
                    // Trees and other non-culled blocks
                    const mergedGeo = mergeGeometries(geometries[blockType]);
                    
                    const originalBlockType = blockType.replace('_culled', '');
                    const isTransparent = originalBlockType === 'water' || originalBlockType === 'glass' || originalBlockType === 'ice';
                    const isFlower = originalBlockType === 'red_flower' || originalBlockType === 'yellow_flower';
                    
                    const mat = new THREE.MeshLambertMaterial({ 
                        map: blockTypes[originalBlockType]?.texture || blockTypes[originalBlockType],
                        transparent: isTransparent || isFlower,
                        opacity: isTransparent ? 0.7 : 1,
                        alphaTest: isFlower ? 0.9 : 0,
                        side: isFlower ? THREE.DoubleSide : THREE.FrontSide
                    });
                    
                    const mesh = new THREE.Mesh(mergedGeo, mat);
                    chunkGroup.add(mesh);
                }
            }
            
            scene.add(chunkGroup);
            chunks[chunkKey] = chunkGroup;
        }

        // Regenerate chunk after block changes
        function regenerateChunk(x, z) {
            const chunkX = Math.floor(x / CHUNK_SIZE);
            const chunkZ = Math.floor(z / CHUNK_SIZE);
            const chunkKey = `${chunkX},${chunkZ}`;
            
            // Remove old chunk
            if (chunks[chunkKey]) {
                scene.remove(chunks[chunkKey]);
                delete chunks[chunkKey];
            }
            
            // Generate new chunk
            generateChunk(chunkX, chunkZ);
        }

        // Regenerate chunks around a block change
        function regenerateChunksAroundBlock(x, y, z) {
            const chunkX = Math.floor(x / CHUNK_SIZE);
            const chunkZ = Math.floor(z / CHUNK_SIZE);
            
            // Regenerate the chunk containing the block
            regenerateChunk(x, z);
            
            // Regenerate adjacent chunks if the block is on a chunk boundary
            const localX = x - chunkX * CHUNK_SIZE;
            const localZ = z - chunkZ * CHUNK_SIZE;
            
            if (localX === 0) regenerateChunk(x - 1, z);
            if (localX === CHUNK_SIZE - 1) regenerateChunk(x + 1, z);
            if (localZ === 0) regenerateChunk(x, z - 1);
            if (localZ === CHUNK_SIZE - 1) regenerateChunk(x, z + 1);
        }

        // Regenerate all visible chunks (for multiplayer sync)
        function regenerateAllChunks() {
            console.log('Regenerating all chunks...');
            Object.keys(chunks).forEach(chunkKey => {
                const [chunkX, chunkZ] = chunkKey.split(',').map(Number);
                scene.remove(chunks[chunkKey]);
                delete chunks[chunkKey];
                generateChunk(chunkX, chunkZ);
            });
        }


        // Fallback merge function if BufferGeometryUtils not available
        function mergeGeometries(geometries) {
            const merged = new THREE.BufferGeometry();
            const positions = [];
            const normals = [];
            const uvs = [];
            const indices = [];
            let indexOffset = 0;
            
            geometries.forEach(geo => {
                const pos = geo.attributes.position.array;
                const norm = geo.attributes.normal.array;
                const uv = geo.attributes.uv.array;
                const idx = geo.index ? geo.index.array : null;
                
                // Add positions
                for (let i = 0; i < pos.length; i++) positions.push(pos[i]);
                
                // Add normals
                for (let i = 0; i < norm.length; i++) normals.push(norm[i]);
                
                // Add UVs
                for (let i = 0; i < uv.length; i++) uvs.push(uv[i]);
                
                // Add indices with offset
                if (idx) {
                    for (let i = 0; i < idx.length; i++) {
                        indices.push(idx[i] + indexOffset);
                    }
                    indexOffset += pos.length / 3;
                } else {
                    // No indices, create them
                    for (let i = 0; i < pos.length / 3; i++) {
                        indices.push(indexOffset + i);
                    }
                    indexOffset += pos.length / 3;
                }
            });
            
            merged.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            merged.setAttribute('normal', new THREE.Float32BufferAttribute(normals, 3));
            merged.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
            merged.setIndex(indices);
            
            return merged;
        }

        // Unload distant chunks
        function updateChunks(playerX, playerZ) {
            const playerChunkX = Math.floor(playerX / CHUNK_SIZE);
            const playerChunkZ = Math.floor(playerZ / CHUNK_SIZE);
            
            // Generate nearby chunks
            for (let cx = playerChunkX - RENDER_DISTANCE; cx <= playerChunkX + RENDER_DISTANCE; cx++) {
                for (let cz = playerChunkZ - RENDER_DISTANCE; cz <= playerChunkZ + RENDER_DISTANCE; cz++) {
                    generateChunk(cx, cz);
                }
            }
            
            // Unload far chunks
            for (const chunkKey in chunks) {
                const [cx, cz] = chunkKey.split(',').map(Number);
                const dist = Math.max(Math.abs(cx - playerChunkX), Math.abs(cz - playerChunkZ));
                
                if (dist > RENDER_DISTANCE + 1) {
                    scene.remove(chunks[chunkKey]);
                    delete chunks[chunkKey];
                }
            }
        }

        // Generate terrain with progress bar
        async function generateTerrain() {
            const progressBar = document.getElementById('progressBar');
            const progressPercent = document.getElementById('loadingPercent');
            const loadingText = document.getElementById('loadingText');

            loadingText.textContent = 'Generating height map...';
            generateHeightMap();
            
            progressBar.style.width = '50%';
            progressPercent.textContent = '50%';
            await new Promise(resolve => setTimeout(resolve, 100));
            
            loadingText.textContent = 'Loading initial chunks...';
            updateChunks(0, 0);
            
            progressBar.style.width = '100%';
            progressPercent.textContent = '100%';
            loadingText.textContent = 'World ready! Click to start...';
            await new Promise(resolve => setTimeout(resolve, 500));
            document.getElementById('loadingScreen').style.display = 'none';
        }
        
        // Mob functions
        function createMob(type) {
            const mob = {
                type: type,
                health: 10,
                x: camera.position.x + (Math.random() - 0.5) * 50,
                z: camera.position.z + (Math.random() - 0.5) * 50,
                y: 40,
                mesh: null
            };
            
            // Create mob mesh
            const geometry = new THREE.BoxGeometry(0.8, 1.8, 0.8);
            const material = new THREE.MeshLambertMaterial({
                color: type === 'zombie' ? 0x00FF00 : 0xFFFFFF
            });
            mob.mesh = new THREE.Mesh(geometry, material);
            mob.mesh.position.set(mob.x, mob.y, mob.z);
            scene.add(mob.mesh);
            
            return mob;
        }
        
        function spawnMobs() {
            // Spawn 5-10 mobs around player
            const mobCount = 5 + Math.floor(Math.random() * 5);
            for (let i = 0; i < mobCount; i++) {
                const type = Math.random() < 0.5 ? 'zombie' : 'skeleton';
                mobs.push(createMob(type));
            }
            console.log(`Spawned ${mobCount} mobs`);
        }
        
        // Animal functions
        function createAnimal(animalType) {
            const animal = {
                type: animalType.type,
                x: camera.position.x + (Math.random() - 0.5) * 40,
                z: camera.position.z + (Math.random() - 0.5) * 40,
                y: 40,
                vx: (Math.random() - 0.5) * 0.02,
                vz: (Math.random() - 0.5) * 0.02,
                mesh: null
            };
            
            const geometry = new THREE.BoxGeometry(animalType.size, animalType.size * 0.8, animalType.size);
            const material = new THREE.MeshLambertMaterial({ color: animalType.color });
            animal.mesh = new THREE.Mesh(geometry, material);
            animal.mesh.position.set(animal.x, animal.y, animal.z);
            scene.add(animal.mesh);
            
            return animal;
        }
        
        function spawnAnimals() {
            const animalCount = 3 + Math.floor(Math.random() * 3);
            for (let i = 0; i < animalCount; i++) {
                const type = animalTypes[Math.floor(Math.random() * animalTypes.length)];
                animals.push(createAnimal(type));
            }
            console.log(`Spawned ${animalCount} animals`);
        }
        
        function updateAnimals() {
            animals.forEach(animal => {
                // Simple AI: Random movement every few frames
                if (Math.random() < 0.02) {
                    animal.vx = (Math.random() - 0.5) * 0.06;
                    animal.vz = (Math.random() - 0.5) * 0.06;
                }
                
                // Apply movement
                animal.x += animal.vx;
                animal.z += animal.vz;
                
                // Apply gravity
                if (!animal.vy) animal.vy = 0;
                animal.vy -= 0.02; // Gravity
                animal.y += animal.vy;
                
                // Ground collision
                const groundHeight = getTerrainHeight(animal.x, animal.z) + 0.5;
                if (animal.y <= groundHeight) {
                    animal.y = groundHeight;
                    animal.vy = 0;
                    // Random jump
                    if (Math.random() < 0.01) {
                        animal.vy = 0.15;
                    }
                }
                
                // Friction
                animal.vx *= 0.95;
                animal.vz *= 0.95;
                
                // Avoid falling off edges
                const nextGroundHeight = getTerrainHeight(animal.x + animal.vx * 10, animal.z + animal.vz * 10);
                if (Math.abs(nextGroundHeight - animal.y) > 3) {
                    animal.vx *= -0.5;
                    animal.vz *= -0.5;
                }
                
                // Update mesh position
                if (animal.mesh) {
                    animal.mesh.position.set(animal.x, animal.y, animal.z);
                    // Rotate to face movement direction
                    if (Math.abs(animal.vx) > 0.01 || Math.abs(animal.vz) > 0.01) {
                        animal.mesh.rotation.y = Math.atan2(animal.vx, animal.vz);
                    }
                }
            });
        }
        
        function updateMobs() {
            mobs.forEach((mob, index) => {
                // Move toward player
                const dx = camera.position.x - mob.x;
                const dz = camera.position.z - mob.z;
                const distance = Math.sqrt(dx * dx + dz * dz);
                
                if (distance > 2 && distance < 50) {
                    const speed = 0.05;
                    mob.x += (dx / distance) * speed;
                    mob.z += (dz / distance) * speed;
                    
                    // Update mob position
                    if (mob.mesh) {
                        mob.mesh.position.x = mob.x;
                        mob.mesh.position.z = mob.z;
                    }
                }
                
                // Check collision with player
                if (distance < 1.5) {
                    takeDamage(1);
                    // Knock mob back
                    mob.x -= (dx / distance) * 2;
                    mob.z -= (dz / distance) * 2;
                }
                
                // Remove dead mobs
                if (mob.health <= 0) {
                    scene.remove(mob.mesh);
                    mobs.splice(index, 1);
                }
            });
        }
        
        // Initialize game
        function initGame() {
            initUI();
            generateTerrain().then(() => {
                spawnAnimals();
                // Flying mode enabled - no gravity, no mobs
                
                // Load blocks from multiplayer after terrain is ready
                if (pendingBlocks) {
                    console.log('Loading pending blocks after terrain generation:', Object.keys(pendingBlocks).length);
                    Object.keys(pendingBlocks).forEach(key => {
                        const [x, y, z] = key.split(',').map(Number);
                        const blockType = pendingBlocks[key];
                        setBlockType(x, y, z, blockType);
                    });
                    regenerateAllChunks();
                    pendingBlocks = null; // Clear pending blocks
                }
            });
        }
        
        // Multiplayer functions
        function connectMultiplayer() {
            try {
                ws = new WebSocket('ws://localhost:8765');
                
                ws.onopen = () => {
                    console.log('Connected to multiplayer server!');
                    isMultiplayer = true;
                    // Send join message
                    ws.send(JSON.stringify({
                        type: 'join',
                        name: playerName,
                        worldType: selectedWorldType
                    }));
                };
                
                ws.onmessage = (event) => {
                    const data = JSON.parse(event.data);
                    
                    if (data.type === 'playerUpdate') {
                        updateOtherPlayer(data.id, data.position, data.rotation, data.name);
                    } else if (data.type === 'playerLeft') {
                        removeOtherPlayer(data.id);
                    } else if (data.type === 'blockChange') {
                        // Update block from other player
                        const key = `${data.x},${data.y},${data.z}`;
                        world[key] = data.blockType;
                        regenerateChunk(data.x, data.z);
                    }
                };
                
                ws.onerror = () => {
                    console.log('Multiplayer server not available - playing solo');
                    isMultiplayer = false;
                };
                
                ws.onclose = () => {
                    console.log('Disconnected from multiplayer server');
                    isMultiplayer = false;
                };
            } catch (e) {
                console.log('Could not connect to multiplayer server');
                isMultiplayer = false;
            }
        }
        
        function sendPlayerUpdate() {
            if (isMultiplayer && ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'playerUpdate',
                    position: {
                        x: camera.position.x,
                        y: camera.position.y,
                        z: camera.position.z
                    },
                    rotation: {
                        yaw: yaw,
                        pitch: pitch
                    }
                }));
            }
        }
        
        function sendBlockChange(x, y, z, blockType) {
            if (isMultiplayer && ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'blockChange',
                    x: x,
                    y: y,
                    z: z,
                    blockType: blockType
                }));
            }
        }
        
        function updateOtherPlayer(id, position, rotation, name) {
            if (!otherPlayers[id]) {
                // Create new player
                const geometry = new THREE.BoxGeometry(0.8, 1.8, 0.8);
                const material = new THREE.MeshLambertMaterial({ color: 0x0088FF });
                const mesh = new THREE.Mesh(geometry, material);
                
                // Add name label
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 256;
                canvas.height = 64;
                ctx.fillStyle = 'white';
                ctx.font = 'bold 48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(name, 128, 48);
                
                const texture = new THREE.CanvasTexture(canvas);
                const spriteMaterial = new THREE.SpriteMaterial({ map: texture });
                const sprite = new THREE.Sprite(spriteMaterial);
                sprite.scale.set(2, 0.5, 1);
                sprite.position.y = 1.5;
                mesh.add(sprite);
                
                scene.add(mesh);
                otherPlayers[id] = { mesh: mesh, name: name };
            }
            
            // Update player position
            if (otherPlayers[id]) {
                otherPlayers[id].mesh.position.set(position.x, position.y, position.z);
                otherPlayers[id].mesh.rotation.y = rotation.yaw;
            }
        }
        
        function removeOtherPlayer(id) {
            if (otherPlayers[id]) {
                scene.remove(otherPlayers[id].mesh);
                delete otherPlayers[id];
            }
        }

        // Player (flying)
        camera.position.set(0, 40, 0); // Spawn close to ground
        let lastChunkUpdate = { x: 0, z: 0 };

        // Game loop
        function animate() {
            requestAnimationFrame(animate);
            
            if (!gameStarted) return; // Don't update before game starts

            // Update camera rotation
            camera.quaternion.setFromEuler(new THREE.Euler(pitch, yaw, 0, 'YXZ'));
            
            // Update player mesh position
            if (playerMesh && thirdPerson) {
                playerMesh.position.copy(camera.position);
                playerMesh.position.y -= 0.9; // Center at feet
                playerMesh.rotation.y = yaw;
                playerMesh.visible = true; // Ensure it's visible
            }

            // Movement
            const forward = new THREE.Vector3(0, 0, -1).applyQuaternion(camera.quaternion);
            const right = new THREE.Vector3(1, 0, 0).applyQuaternion(camera.quaternion);
            
            forward.y = 0;
            right.y = 0;
            forward.normalize();
            right.normalize();

            if (keys.KeyW) camera.position.add(forward.multiplyScalar(moveSpeed));
            if (keys.KeyS) camera.position.add(forward.multiplyScalar(-moveSpeed));
            if (keys.KeyA) camera.position.add(right.multiplyScalar(-moveSpeed));
            if (keys.KeyD) camera.position.add(right.multiplyScalar(moveSpeed));
            
            // FPS Counter
            if (showFPS) {
                frameCount++;
                const now = Date.now();
                if (now - lastFpsTime >= 1000) {
                    currentFps = frameCount;
                    frameCount = 0;
                    lastFpsTime = now;
                    const info = document.getElementById('info');
                    if (info && info.querySelector('h3')) {
                        const multiplayerText = socket && socket.readyState === WebSocket.OPEN ? ' | MULTIPLAYER' : '';
                        info.querySelector('h3').textContent = `*** MINECRAFT NESA EXPLORER 5 *** | FPS: ${currentFps}${multiplayerText}`;
                    }
                }
            }
            
            // Broadcast player position to multiplayer (throttled to 20 updates/sec)
            if (socket && socket.readyState === WebSocket.OPEN && (!window.lastPositionUpdate || Date.now() - window.lastPositionUpdate > 50)) {
                sendMultiplayer({
                    type: 'playerMovement',
                    x: camera.position.x,
                    y: camera.position.y,
                    z: camera.position.z,
                    rotationY: yaw
                });
                window.lastPositionUpdate = Date.now();
            }
            
            // Flying mode - no gravity
            // Fly up with Space
            if (keys.Space) {
                camera.position.y += FLY_SPEED;
            }
            
            // Broadcast player position to multiplayer (throttled)
            if (!window.lastPositionUpdate || Date.now() - window.lastPositionUpdate > 50) {
                socket.emit('playerMovement', {
                    x: camera.position.x,
                    y: camera.position.y,
                    z: camera.position.z,
                    rotationY: yaw
                });
                window.lastPositionUpdate = Date.now();
            }
            
            // Fly down with Shift
            if (keys.ShiftLeft || keys.ShiftRight) {
                camera.position.y -= FLY_SPEED;
            }
            
            // Keep player above minimum height
            const groundHeight = getTerrainHeight(camera.position.x, camera.position.z) + 1.7;
            if (camera.position.y < groundHeight) {
                camera.position.y = groundHeight;
            }

            // Update chunks when player moves significantly
            const chunkX = Math.floor(camera.position.x / CHUNK_SIZE);
            const chunkZ = Math.floor(camera.position.z / CHUNK_SIZE);
            if (chunkX !== lastChunkUpdate.x || chunkZ !== lastChunkUpdate.z) {
                updateChunks(camera.position.x, camera.position.z);
                lastChunkUpdate = { x: chunkX, z: chunkZ };
            }
            
            // Mobs disabled
            
            // Update animals
            updateAnimals();
            
            // Update particles
            updateParticles();
            
            // Update block targeting cursor
            if (isLocked) {
                const direction = new THREE.Vector3(0, 0, -1);
                direction.applyQuaternion(camera.quaternion);
                raycaster.set(camera.position, direction);
                
                const allMeshes = [];
                for (const chunkKey in chunks) {
                    chunks[chunkKey].children.forEach(mesh => {
                        allMeshes.push(mesh);
                        if (mesh.children && mesh.children.length > 0) {
                            mesh.children.forEach(child => allMeshes.push(child));
                        }
                    });
                }
                
                const intersects = raycaster.intersectObjects(allMeshes, true);
                
                if (intersects.length > 0) {
                    const intersect = intersects[0];
                    const hitPoint = intersect.point;
                    const normal = intersect.face.normal;
                    
                    // Calculate block being looked at
                    const blockX = Math.floor(hitPoint.x - normal.x * 0.5);
                    const blockY = Math.floor(hitPoint.y - normal.y * 0.5);
                    const blockZ = Math.floor(hitPoint.z - normal.z * 0.5);
                    
                    // Calculate placement position
                    const placeX = Math.floor(hitPoint.x + normal.x * 0.5);
                    const placeY = Math.floor(hitPoint.y + normal.y * 0.5);
                    const placeZ = Math.floor(hitPoint.z + normal.z * 0.5);
                    
                    targetBlock = {
                        x: blockX,
                        y: blockY,
                        z: blockZ,
                        placeX: placeX,
                        placeY: placeY,
                        placeZ: placeZ,
                        type: getBlockType(blockX, blockY, blockZ)
                    };
                    
                    // Show highlight at target block
                    highlightMesh.position.set(blockX, blockY, blockZ);
                    highlightMesh.visible = true;
                } else {
                    targetBlock = null;
                    highlightMesh.visible = false;
                }
            } else {
                targetBlock = null;
                highlightMesh.visible = false;
            }
            
            // Day/night cycle
            timeOfDay = (timeOfDay + 1) % 24000;
            
            if (timeOfDay < 6000) { // Night
                const nightProgress = timeOfDay / 6000;
                scene.background = new THREE.Color().setHSL(0.6, 0.5, 0.05 + nightProgress * 0.45);
                ambientLight.intensity = 0.2 + nightProgress * 0.4;
                sunLight.visible = false;
                moonLight.visible = true;
            } else if (timeOfDay < 18000) { // Day
                scene.background = new THREE.Color(0x99CCFF);
                ambientLight.intensity = 0.6;
                sunLight.visible = true;
                moonLight.visible = false;
                
                const sunProgress = (timeOfDay - 6000) / 12000;
                const sunAngle = sunProgress * Math.PI;
                sunLight.position.set(
                    Math.cos(sunAngle) * 100,
                    Math.sin(sunAngle) * 100,
                    50
                );
            } else { // Sunset
                const duskProgress = (timeOfDay - 18000) / 6000;
                scene.background = new THREE.Color().setHSL(0.08, 0.8, 0.5 - duskProgress * 0.45);
                ambientLight.intensity = 0.6 - duskProgress * 0.4;
                sunLight.visible = true;
                sunLight.intensity = 0.8 - duskProgress * 0.8;
                moonLight.visible = false;
            }
            
            // Render with camera positioning
            if (thirdPerson && playerMesh) {
                // Calculate camera offset behind player
                const cameraOffset = new THREE.Vector3(0, 2, 5); // 5 units back, 2 units up
                cameraOffset.applyAxisAngle(new THREE.Vector3(0, 1, 0), yaw);
                
                const targetPos = new THREE.Vector3(
                    camera.position.x + cameraOffset.x,
                    camera.position.y + cameraOffset.y,
                    camera.position.z + cameraOffset.z
                );
                
                // Save original camera position
                const originalPos = camera.position.clone();
                const originalRot = camera.rotation.clone();
                
                // Move camera to third-person position
                camera.position.copy(targetPos);
                camera.lookAt(originalPos.x, originalPos.y + 0.5, originalPos.z);
                
                // Render scene
                renderer.render(scene, camera);
                
                // Restore camera
                camera.position.copy(originalPos);
                camera.rotation.copy(originalRot);
            } else {
                renderer.render(scene, camera);
            }
            
            // Send player position to other players (every 3 frames)
            if (gameStarted && isMultiplayer) {
                if (Math.random() < 0.33) {
                    sendPlayerUpdate();
                }
            }
        }

        animate();

        // Fixed 720x480 resolution - no resize needed
    </script>
</body>
</html>
